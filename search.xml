<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>病毒溯源</title>
      <link href="/2024/04/07/%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/"/>
      <url>/2024/04/07/%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="病毒溯源"><a href="#病毒溯源" class="headerlink" title="病毒溯源"></a><a href="https://www.acwing.com/problem/content/description/3468/">病毒溯源</a></h1><p>病毒容易发生变异。</p><p>某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><p>输入格式<br>输入在第一行中给出一个正整数$N$，即病毒种类的总数。于是我们将所有病毒从$0$到$N−1$进行号。</p><p>随后$N$行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k 变异株1 …… 变异株k</span><br></pre></td></tr></table></figure><p>其中$k$是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第$i$行对应编号为$i$的病毒$(0\lt i\leq N)$题目保证病毒源头有且仅有一个。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以$1$个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列${a_1,…,a_n}$比序列${b_1,…,b_n}$“小”，如果存在$1\leq k\leq n$满足$a_i = b_i$对所有$i\lt k$成立，且$a_k\lt b_k$。</p><p>数据范围<br>$1\leq N\leq 10^4$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">10</span><br><span class="line">3 6 4 8</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2 5 9</span><br><span class="line">0</span><br><span class="line">1 7</span><br><span class="line">1 2</span><br><span class="line">0</span><br><span class="line">2 3 1</span><br><span class="line">输出样例：</span><br><span class="line">4</span><br><span class="line">0 4 9 1</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>树形$DP$，$f[j]$表示以j为根节点的子树的所有链的最大值；</p><p>注意，题目要求字典序最小，即如果$f[j]$在更新时需要特殊处理相等的情况，具体请看代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t,a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    f[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[root]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(f[root] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">            f[root] = f[j] + <span class="number">1</span>;</span><br><span class="line">            path[root] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须是先更新小于，在考虑等于时的情况，才能保证一定是更新到等长链中的编号较小的节点的路径</span></span><br><span class="line">        <span class="keyword">if</span>(f[root] &lt;= f[j] + <span class="number">1</span>) path[root] = <span class="built_in">min</span>(path[root],j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">        path[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">add</span>(i,a);</span><br><span class="line">            has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_fa[root]) ++ root;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[root]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = root; path[i] != <span class="number">0x3f3f3f3f</span>; i = path[i]) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有上司的舞会</title>
      <link href="/2024/04/07/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"/>
      <url>/2024/04/07/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a><a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个整数 $n$。</p><p>第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。</p><p>第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表最大的快乐指数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>化整为零，先考虑子问题；</p><p>一棵树的最大值可由它的子树转移而来，且根节点的选择与否直接影响到子树的最大值，所以需要记录一个状态$0$表示不选根节点，$1$表示选择根节点；</p><p>$f[i][j]$表示以$i$为根的子树，$j$可以取$0$或者$1$，分别表示选择节点$i$的与否，其属性存储最大值。</p><p>我们需要从叶子节点开始，逐步转移到根节点，这里采用 DFS 进行搜素。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[root] == <span class="number">-1</span>) &#123;</span><br><span class="line">        f[root][<span class="number">0</span>] = <span class="number">0</span>,f[root][<span class="number">1</span>] = happy[root];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[root]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[root][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>],f[j][<span class="number">1</span>]);</span><br><span class="line">        f[root][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[root][<span class="number">1</span>] += happy[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        ++d[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单状压DP</title>
      <link href="/2024/04/07/%E7%AE%80%E5%8D%95%E7%8A%B6%E5%8E%8BDP/"/>
      <url>/2024/04/07/%E7%AE%80%E5%8D%95%E7%8A%B6%E5%8E%8BDP/</url>
      
        <content type="html"><![CDATA[<h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a></h1><p>给定一张$n$个点的带权无向图，点从$0∼n−1$标号，求起点$0$到终点$n−1$的最短 Hamilton 路径。</p><p><strong>输入格式</strong></p><p>第一行输入整数$n$。</p><p>接下来$n$行每行$n$个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为$a[i,j]$）。</p><p>对于任意的$x,y,z$，数据保证$a[x,x]=0$，$a[x,y]=a[y,x]$ 并且$a[x,y]+a[y,z]≥a[x,z]$。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最短 Hamilton 路径的长度。</p><p><strong>数据范围</strong></p><p>$1≤n≤20$</p><p>$0≤a[i,j]≤10^7$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">5</span><br><span class="line">0 2 4 5 1</span><br><span class="line">2 0 6 5 3</span><br><span class="line">4 6 0 8 3</span><br><span class="line">5 5 8 0 5</span><br><span class="line">1 3 3 5 0</span><br><span class="line">输出样例：</span><br><span class="line">18</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一道经典的旅行商 NP 问题。</p><p>一共 20 个点，共 20！种排列方式，暴力搜素肯定行不通；</p><p>观察这样两条路径：</p><ul><li><p>0 -&gt; 1 -&gt; 2 -&gt; 3 长度为18</p></li><li><p>0 -&gt; 2 -&gt; 1 -&gt; 3 长度为20</p></li></ul><p>显然，长度为 20 的路径肯定不是最终答案，我们不需要考虑这条路径；</p><p>因此问题转化为考虑经过了哪些点后最终到达某个点的最短 Hamilton 路径长度。</p><p>$f[i][j]$：$i$是一个二进制数，表示到达$j$点经过了哪些点，显然$i$的第$j$位保证为$1$；</p><p>$f[i][j]$可以由所有的第$j$位为$0$，第$k$位为$1$的状态$f[stk][k]$转移而来。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">1</span> &lt;&lt; N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">//起点长度为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)  <span class="comment">// 保证合法状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ;k &lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span>((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">// 合法状态</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="蓝桥杯-2023-省-B-飞机降落"><a href="#蓝桥杯-2023-省-B-飞机降落" class="headerlink" title="蓝桥杯 2023 省 B 飞机降落"></a><a href="https://www.luogu.com.cn/problem/P9241">蓝桥杯 2023 省 B</a> 飞机降落</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第$i$架飞机在$T[i]$时刻到达机场上空，到达时它的剩余油料还可以继续盘旋$D[i]$个单位时间，即它最早可以于$T[i]$时刻开始降落，最晩可以于$T[i] + D[i]$时刻开始降落。降落过程需要$L[i]$个单位时间。</p><p>一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。</p><p>请你判断$N架$飞机是否可以全部安全降落。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组数据。</p><p>第一行包含一个整数$T$，代表测试数据的组数。</p><p>对于每组数据，第一行包含一个整数$N$。</p><p>以下$N$行，每行包含三个整数$T[i],D[i],L[i]$ 。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出 <code>YES</code> 或者 <code>NO</code>，代表是否可以全部安全降落。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">0 100 10</span><br><span class="line">10 10 10</span><br><span class="line">0 2 20</span><br><span class="line">3</span><br><span class="line">0 10 20</span><br><span class="line">10 10 20</span><br><span class="line">20 10 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例说明】</strong></p><p>对于第一组数据，可以安排第$3$架飞机于$0$时刻开始降落，$20$时刻完成降落。安排第$2$架飞机于$20$时刻开始降落，$30$时刻完成降落。安排第$1$架飞机于$30$时刻开始降落，$40$时刻完成降落。</p><p>对于第二组数据，无论如何安排，都会有飞机不能及时降落。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>$f[i][j]$表示$i$中数位为$1$的飞机已经降落且最后一架降落的飞机是$j$的最小落地时间 （显然保证$i$的第$j$位为$1$）</strong></p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[N],d[N],l[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;d[i],&amp;l[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++ i) f[<span class="number">1</span> &lt;&lt; i][i] = t[i] + l[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line">                        <span class="keyword">if</span>(i - (<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; f[i - (<span class="number">1</span> &lt;&lt; j)][k] &lt;= t[j] + d[j])</span><br><span class="line">                            f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(t[j],f[i - (<span class="number">1</span> &lt;&lt; j)][k]) + l[j]);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            res = <span class="built_in">min</span>(f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j],res);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a><a href="https://www.acwing.com/problem/content/3497/">国际象棋</a></h1><p>众所周知，“八皇后” 问题是求解在国际象棋棋盘上摆放$8$个皇后，使得两两之间互不攻击的方案数。</p><p>已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹未尽。作为一个国际象棋迷，他想研究在$N \times M$的棋盘上，摆放$K$个马，使得两两之间互不攻击有多少种摆放方案。</p><p>由于方案数可能很大，只需计算答案除以$1000000007$(即$10^9+7$) 的余数。</p><p>如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字，位于 (x,y) 格的马（第 x 行第 y<br>列）可以攻击 $(x+1,y+2)$、$(x+1,y−2)$、$(x−1,y+2)$、$(x−1,y−2)$、$(x+2,y+1)$、$(x+2,y−1)$、$(x−2,y+1)$ 和 $(x−2,y−1)$ 共 8 个格子。</p><p><img src="/img/guojixiangqi.png" alt="国际象棋"></p><p><strong>输入格式</strong><br>输入一行包含三个正整数$N,M,K$，分别表示棋盘的行数、列数和马的个数。</p><p><strong>输出格式</strong><br>输出一个整数，表示摆放的方案数除以$1000000007$(即$10^9+7$) 的余数。</p><p><strong>数据范围</strong><br>对于 5% 的评测用例，$K=1$；对于另外 10% 的评测用例，$K=2$；<br>对于另外 10% 的评测用例，$N=1$；<br>对于另外 20% 的评测用例，$N,M≤6$，$K≤5$；<br>对于另外 25% 的评测用例，$N≤3，M≤20，K≤12$；<br>对于所有评测用例，$1≤N≤6，1≤M≤100，1≤K≤20$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入样例1：</span><br><span class="line">1 2 1</span><br><span class="line">输出样例1：</span><br><span class="line">2</span><br><span class="line">输入样例2：</span><br><span class="line">4 4 3</span><br><span class="line">输出样例2：</span><br><span class="line">276</span><br><span class="line">输入样例3：</span><br><span class="line">3 20 12</span><br><span class="line">输出样例3：</span><br><span class="line">914051446</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>$dp$问题的显著特征就是可以<strong>把大问题化成小问题，再化零为整</strong>；</p><p>考虑棋子的放置过程，显然如果一列一列的放置棋子，显然棋子的放置只会受到前两列的影响（同一列棋子显然不会发生冲突）；</p><p>于是我们考虑子问题：前$i$列已经放置完毕，并且第$i$列和第$i-1$列的状态分别是$a$、$b$，且已经放置了$j$枚棋子的方案数；</p><p>这时我们只需要顺序枚举每一列 $i$、$i - 1$ 列、 $i$ 列、$i - 2$列、棋子数目$j$即可；</p><p>最多循环次数$100 \times 64 \times 64 \times 64 \times 20$次;</p><p>这个数字大约是$5 \times 10^9$；</p><p>但是在枚举过程中状态之间需要保证不发生冲突，即$a$与$b$不能出现间隔$2$位为$1$的情况，<br>$c$与$a$同理，并且$c$与$b$不能出现间隔$1$位为$1$的情况；</p><p>此外，$j$的枚举从$b$中有的$1$的个数开始，到$k$结束；</p><p>在实际运行中，大约运算了七百多万次。</p><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>,M = <span class="number">110</span>,mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1</span> &lt;&lt; n; ++ a)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1</span> &lt;&lt; n; ++ b) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a &amp; (b &lt;&lt; <span class="number">2</span>) || b &amp; (a &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">1</span> &lt;&lt; n; ++ c) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(a &amp; (c &lt;&lt; <span class="number">2</span>) || c &amp; (a &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(c &amp; (b &lt;&lt; <span class="number">1</span>) || b &amp; (c &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">int</span> w = <span class="built_in">get</span>(b),v = <span class="built_in">get</span>(a);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j = v + w; j &lt;= k; ++ j)</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="built_in">get</span>(c) + v; t &lt;= k - w; ++ t)</span><br><span class="line">                                f[i][a][b][j] = (f[i][a][b][j] + f[i<span class="number">-1</span>][c][a][t])</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1</span> &lt;&lt; n; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1</span> &lt;&lt; n; ++ b)</span><br><span class="line">            res  = (res + f[m][a][b][k]) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 状压DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒙德里安的梦想</title>
      <link href="/2024/04/06/%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/"/>
      <url>/2024/04/06/%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙德里安的猜想"><a href="#蒙德里安的猜想" class="headerlink" title="蒙德里安的猜想"></a><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3842/">蒙德里安的猜想</a></h1><p>求把$N \times M$的棋盘分割成若干个$1 \times 2$的长方形，有多少种方案。</p><p>例如当$N=2$，$M=4$时，共有$5$种方案。当$N=2$，$M=3$时，共有$3$种方案。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组测试用例。</p><p>每组测试用例占一行，包含两个整数$N$和$M$。</p><p>当输入用例$N=0$，$M=0$时，表示输入终止，且该用例无需处理。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>每个测试用例输出一个结果，每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq N,M\leq 11$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br><span class="line">输出样例：</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure><p><img src="/img/dp1.jpg" alt="蒙德里安的梦想"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>数据范围为 1 ~ 11 ，考虑进行状压dp</strong></p><p>棋盘面积一定是偶数，否则不存在合法方案（本题保证一定合法）；</p><p>长方形的放置只存在横向和纵向两种方案，现只考虑横向放置长方形。当所有横向长方形防止完毕，纵向方案唯一确定。故只需考虑横向放置即可；</p><p>$f[i][j]$表示前$i-1$列已经放置好，且从第$i-1$列延伸出来的$1 \times 1$的小正方形的排列方式为$j$（$j$看成$n$位二进制数，第$d$行存在延伸过来的小正方形，则$j$的第$d$位为$1$，否则为$0$）的所有方案数；</p><p>状态转移：考虑由$f[i-1][k]$转移。合法的转移情况保证$j$和$k$的同一数位不能都是$1$，否则会发生重叠；并且当第$i$列、第$i-1$列放置完后，不允许存在由连续奇数行没有横向长方形；</p><p>对应上述两种情况，保证 <code>i &amp; k == 0</code> 且 <code>i | k 中没有连续奇数个0</code>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>,M = <span class="number">1</span> &lt;&lt; N;    <span class="comment">//N行，M中状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[M]; <span class="comment">//预处理所有合法状态</span></span><br><span class="line">LL f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m,n || m) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//统计连续0</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) </span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;  <span class="comment">//连续奇数个0，状态不合法</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;  <span class="comment">//注意末尾可能存在奇数个0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化f数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//f[0][0]什么都没放置，仅一种方案        </span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//枚举第i列的所有状态可以由i-1列的哪些状态转移过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])</span><br><span class="line">                        f[i][j] += (LL)f[i<span class="number">-1</span>][k];</span><br><span class="line">        <span class="comment">//f[m][0]表示前m-1列放好，且第m列没有任何延伸。注意，数组从0开始</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[m][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 状压DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
