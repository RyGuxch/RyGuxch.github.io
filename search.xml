<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>math</title>
      <link href="/2025/06/20/math/"/>
      <url>/2025/06/20/math/</url>
      
        <content type="html"><![CDATA[<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h2><h3 id="判定质数-1"><a href="#判定质数-1" class="headerlink" title="判定质数"></a>判定质数</h3><p>假设  $d | n$ ，则有  $\frac{n}{d} | n$ ，不妨设 $d \lt \frac{n}{d}$，则 $d &lt; \sqrt{n}$，</p><p>因此试除法判定质数的判断条件可以写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br></pre></td></tr></table></figure><h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><p>任意一个合数 $m$ 都可以写成 $m = p \times q$ ，其中 $p$ 为最小质因子，因此可以用线性筛。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> st[N];<span class="comment">//用以记录哪些数被筛除</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ger_primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt ++] = i;<span class="comment">// 没被筛的一定是质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++ j) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层循环保证遍历，每一个 q ，内层循环保证用最小质因子 p 筛掉合数， 并且当  i % primes[j] == 0 时，break， 因为此后就不是用最小质因子筛选</span></span><br></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p>任意一个数都有 $m = p_1^{x_1} \times p_2^{x_2} \times … \times p_n^{x_n}$，其中 $P_i \in 质数$，根据组合原理，则数 $m$ 的 <strong>约数个数</strong> 为 $(x_1 + 1) \times (x_2 + 1) \times … \times (x_n + 1)$。</p><p><strong>约数之和</strong> 就是上述每一种取值求和，意即：$\sum{d} = \sum<em>{x_1=0}^{a_1}\sum</em>{a<em>2=0}^{x_2}…\sum</em>{a_n=0}^{x_n}(p_1^{a_1} \times p_2^{a_2} \times … \times p_n^{a_n})$</p><p>整理得：$\sum{d}=\prod<em>{i=0}^{n}(\sum</em>{a_i=0}^{x_i}p_i^{a_i})$</p><p><strong>最大公约数</strong>: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 $d | a, d | b, a \% b = a - kb$，则有 $d | a - kb$，因此 $d$ 也是 $(b, a \% b)$ 的约数；反之，假设 $d | b, d | a\%b$，意即 $d | b, d | a - kb$，则 $d | a - kb + kb$，即 $d$ 也是 $(a,b)$ 的约数。</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$1 \sim N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $\phi(N)$ ，在算数基本定理中有 $\phi(N)=N\prod_{i=1}^{n}(1 - \frac{1}{p_i})$ 。</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>本质上是二分快速求幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b. imt p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>若整数 $b,m$ 互质，并且对于任意的整数 $a$，如果满足 $b | a$ ，则存在一个整数 $x$，使得 $\frac{a}{b} \equiv a \times x \pmod m$，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1} \pmod m$。</p><p>$b$ 存在乘法逆元的充要条件是 $b$ 与 模数 $m$ 互质，当 $m$ 为质数时，$b^{m-2}$ 即为 $b$ 的乘法逆元。</p><h3 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h3><p>对于数 $a,b$，求出一组数 $x,y$，满足 $a \times x + b \times y = gcd(a,b)$。</p><p>当 $b=0$ 时，显然有 $gcd(a,b) = a, x = 1, y = 0$;</p><p>当 $b \neq 0$ 时，$a \times x + b \times y = gcd(a,b)=gcd(b, a \% b)$;</p><p>进一步，$b \times x’ + (a - \left\lfloor a/b \right\rfloor* b) \times y’ = gcd(a, a \% b)$;</p><p>整理可得：$x = y’, y = x’ - \left\lfloor a/b \right\rfloor* y’$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1, y = x1 - a / b * y1;</span><br><span class="line">    retu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>$a \times x \equiv b \pmod m$ 意即 $a \times x - b$ 一定是 $m$ 的倍数，因此线性同余方程等价为 $a \times x + m \times y = b$；</p><p>根据贝祖定理，上述等式有解的充要条件是 $gcd(a, m) | b$；</p><p>因此通过扩展欧几里德算法求出特解 $x_0$ 后，$x = x_0 \times \frac{b}{gcd(a,m)} \% m$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>greedy</title>
      <link href="/2025/06/20/greedy/"/>
      <url>/2025/06/20/greedy/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $N$ 个闭区间 $[a_i, b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。<br><strong>注意</strong>：位于区间端点上的点也算作区间内。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>第一行包含一个整数 $N$，表示区间的数量。  </li><li>接下来 $N$ 行，每行包含两个整数 $a_i$ 和 $b_i$，表示一个区间的两个端点。</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示所需的点的最小数量。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1 \leq N \leq 10^5$  </li><li>$-10^9 \leq a_i \leq b_i \leq 10^9$</li></ul><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">5 7</span><br><span class="line">6 8</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>区间按右端点非递减排序，每次选取右端点。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>假设最优解是 $res$ ，贪心算法的解是 $cnt$ ，那么有: $res \leq cnt$ ；按照贪心算法，只有区间不相交时才会选取，意即至少有 $cnt$ 个不相交的区间，至少需要 $cnt$ 个点，那么有 $res \ge cnt$ ；因此 $res = cnt$ 。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ed = <span class="number">-2e9</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg: segs) </span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first) ++ res, ed = seg.second;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $N$ 个闭区间 $[a_i, b_i]$，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。<br>输出可选取区间的最大数量。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>第一行包含一个整数 $N$，表示区间数。  </li><li>接下来 $N$ 行，每行包含两个整数 $a_i, b_i$，表示一个区间的两个端点。</li></ul><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示可选取的区间的最大数量。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1 \leq N \leq 10^5$  </li><li>$-10^9 \leq a_i \leq b_i \leq 10^9$</li></ul><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>以右端点非递减排序，遍历，每次比较当前区间的左端点与 $ed$ ，若大于，则选择。</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>假设最优解与贪心解分别为 $res, cnt$ , 那么有 $res \ge cnt$；考虑  $cnt$ 的求法，每一个选中的区间必然 $pass$ 掉若干右端点比它大的区间，并且这些区间的左端点小于该区间的右端点，将这些区间看成一个集合，因此共有 $cnt$ 个集合，每一个集合内的区间都<strong>两两相交</strong>；根据抽屉原理，若 $ans \gt cnt$ ，则 $ans$ 中必然有两个区间在同一个集合，矛盾，因此 $ans \le cnt$， 因此 $ans = cnt$。 </p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII a, PII b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;cin &gt;&gt; a &gt;&gt; b; segs.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a, b));&#125;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> st, ed;</span><br><span class="line">    st = ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg: segs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.x) ++ res, st = seg.x, ed = seg.y;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间分组问题"><a href="#区间分组问题" class="headerlink" title="区间分组问题"></a>区间分组问题</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $N$ 个闭区间 $[a_i, b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。<br>输出最小组数。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>第一行包含整数 $N$，表示区间数量。  </li><li>接下来 $N$ 行，每行包含两个整数 $a_i, b_i$，表示一个区间的左右端点。</li></ul><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示将所有区间分组后的最小组数。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1 \le N \le 10^5$  </li><li>$-10^9 \le a_i \le b_i \le 10^9$</li></ul><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>将区间按照左端点排序，遍历，每次判断该区间是否能放入某个集合，若不能，则新开一个集合；对于每个集合，维护一个最大右端点值，由于是以左端点排序，那么只要当前遍历到的区间的左端点大于右端点，就能放入到该集合内；进一步的，维护所集合的最右端点值，每次尽可能放入具有最小右端点值的集合。</p><h4 id="证明思路"><a href="#证明思路" class="headerlink" title="证明思路"></a>证明思路</h4><p>按照算法，每次引起新建集合的区间必定和当前集合的所有区间两两相交，因此至少需要 $cnt$ 个集合，有 $res \ge cnt$;</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> e &amp;w)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;segs[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; segs[i].l &gt;&gt; segs[i].r;</span><br><span class="line">    <span class="built_in">sort</span>(segs + <span class="number">1</span>, segs + n + <span class="number">1</span>);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= segs[i].l) heap.<span class="built_in">push</span>(segs[i].r);</span><br><span class="line">        <span class="keyword">else</span> heap.<span class="built_in">pop</span>(), heap.<span class="built_in">push</span>(segs[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; heap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间覆盖问题（指定区间完全覆盖）"><a href="#区间覆盖问题（指定区间完全覆盖）" class="headerlink" title="区间覆盖问题（指定区间完全覆盖）"></a>区间覆盖问题（指定区间完全覆盖）</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $N$ 个区间 $[a_i, b_i]$ 以及一个目标区间 $[s, t]$，请你从这 $N$ 个区间中选择尽量少的区间，使得所选区间的并集能够完全覆盖目标区间 $[s, t]$。如果无法覆盖则输出 $-1$。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>第一行包含两个整数 $s$ 和 $t$，表示目标区间的左右端点。  </li><li>第二行包含一个整数 $N$，表示给定区间的数量。  </li><li>接下来 $N$ 行，每行包含两个整数 $a_i, b_i$，表示第 $i$ 个区间的左右端点。</li></ul><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示所需的最少区间数量；如果无法完全覆盖则输出 <code>-1</code>。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1 \le N \le 10^5$  </li><li>$-10^9 \le a_i \le b_i \le 10^9$  </li><li>$-10^9 \le s \le t \le 10^9$</li></ul><h4 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">3</span><br><span class="line">-1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>以左端点排序，每次选择尽可能覆盖更多的区间。</p><h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>按照算法，每次选择的都是左端点小于 $st$ ，右端点尽可能大的区间；如果 $ans \lt cnt$ , 那么 $cnt$ 中必然至少有两个区间可以被一个区间代替，这与算法矛盾，因为这样的区间必然会被算法在前次遍历时选取，因此 $an \ge cnt$</p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">PII segs[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII a, PII b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> st, ed, n;</span><br><span class="line">    cin &gt;&gt; st &gt;&gt; ed &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; segs[i].x &gt;&gt; segs[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(segs + <span class="number">1</span>, segs + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> j = i, b = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n &amp;&amp; segs[j].x &lt;= st) &#123;</span><br><span class="line">            b = <span class="built_in">max</span>(b, segs[j].y);</span><br><span class="line">            ++ j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; st) &#123;success = <span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        ++ res;</span><br><span class="line">        <span class="keyword">if</span>(b &gt;= ed) &#123;success = <span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        st = b, i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!success) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叠罗汉问题（奶牛垂直堆叠风险最小化）"><a href="#叠罗汉问题（奶牛垂直堆叠风险最小化）" class="headerlink" title="叠罗汉问题（奶牛垂直堆叠风险最小化）"></a>叠罗汉问题（奶牛垂直堆叠风险最小化）</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>农民约翰的 (N) 头奶牛（编号为 (1\ldots N)）计划逃跑并加入马戏团，为此它们练习“叠罗汉”杂技：奶牛站在彼此的身上，形成一个高高的垂直堆叠。每头奶牛都有重量 (W_i) 和强壮程度 (S_i)。当奶牛 (i) 站在一系列奶牛上时，其<strong>风险值</strong>定义为其上方所有奶牛的总重量（不包括自己）减去它的强壮程度：  </p><script type="math/tex; mode=display">\mathrm{风险值}_i \;=\;\Bigl(\sum_{\substack{j\text{ 在 }i\text{ 之上}}} W_j\Bigr)\;-\;S_i.</script><p>风险值越大，这头奶牛撑不住的可能性越高。请为这些奶牛找出一种排列顺序，使得所有奶牛的风险值中的最大值尽可能小。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>第一行包含一个整数 (N)，表示奶牛数量。  </li><li>接下来 (N) 行，每行包含两个整数 (W_i) 和 (S_i)，分别表示第 (i) 头奶牛的重量和强壮程度。</li></ul><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示在最优排列下，所有奶牛的<strong>最大风险值</strong>的最小可能值。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li>$1 \le N \le 50000$  </li><li>$1 \le W_i \le 10000$</li><li>$1 \le S_i \le 10^9$</li></ul><h4 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">2 5</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h4 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>按照 $w + s$ 排序即可。</p><h4 id="证明思路-1"><a href="#证明思路-1" class="headerlink" title="证明思路"></a>证明思路</h4><p>考察相邻的两头牛 $i, i + 1$ 是否需要交换，它们的交换不影响其余牛的危险值。</p><p>交换前：$i: \sum^{i-1}<em>{j = 1}w_j - s_i, i + 1: \sum^{i}</em>{j=1}w<em>j - s</em>{i+1}$</p><p>交换后：$i: \sum^{i-1}<em>{j=1}w_j + w</em>{i+1} - s<em>i, i + 1: \sum^{i-1}</em>{j=1}w<em>j - s</em>{i+1}$</p><p>比较交换后的 $i$ 与交换前的 $i + 1$即可。</p><p>此时假设：$\sum^{i-1}<em>{j=1}w_j + w</em>{i+1} - s<em>i \ge \sum^{i}</em>{j=1}w<em>j - s</em>{i+1}$</p><p>即：$w<em>{i+1} - s_i \ge w_i - s</em>{i+1}$</p><p>即：$w<em>{i+1} + s</em>{i+1} \ge w_i + s_i$</p><p>即如果满足上式，则交换后的危险值会变大，意即 $w + s$ 大的应该排在后。</p><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line">    <span class="type">int</span> w, s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> e &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w + s &lt; x.w + x.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;cows[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; cows[i].w &gt;&gt; cows[i].s;</span><br><span class="line">    <span class="built_in">sort</span>(cows + <span class="number">1</span>, cows + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>, weight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, weight - cows[i].s);</span><br><span class="line">        weight += cows[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究总结</title>
      <link href="/2025/06/17/%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2025/06/17/%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><h2 id="多模态融合"><a href="#多模态融合" class="headerlink" title="多模态融合"></a>多模态融合</h2><blockquote><p>不同模态具有互补信息</p></blockquote><ul><li>特征级融合</li><li>查询级融合</li><li>实例级融合</li></ul><h3 id="特征级融合"><a href="#特征级融合" class="headerlink" title="特征级融合"></a>特征级融合</h3><ul><li>晚期融合</li><li>中期融合</li><li>早期融合</li></ul><h3 id="晚期融合："><a href="#晚期融合：" class="headerlink" title="晚期融合："></a>晚期融合：</h3><p>晚期融合一般是在proposal上进行融合，如MV3D、Frustum PointNet等：</p><p><img src="/img/image-20250321113152658.png" alt="image-20250321113152658"></p><p><img src="/img/image-20250321113245565.png" alt="image-20250321113245565"></p><p>MV3D利用点云生成的proposal来指导融合，而Frustum PointNet利用图像生成的proposal通过深度采样和投影变换实现多模态的融合，这类方法倾向于单一模态，未能充分利用模态间的互补信息，在单一模态失效的情况下严重影响模型性能</p><h4 id="早期融合"><a href="#早期融合" class="headerlink" title="早期融合"></a>早期融合</h4><p>早期融合一般是在输入层级上进行融合，如PointPainting和PointArgumenting：</p><p><img src="/img/image-20250321114013648.png" alt="image-20250321114013648"></p><p><img src="/img/image-20250321120914856.png" alt="image-20250321120914856"></p><p>PointPainting将图像的语义分割分数经深度估计和投影变换paint在对应的点云上，将图像语义信息融合；PointArgumenting进一步利用图像生成伪点云，并入原始点云，这类方法仍然依赖于单一模态，并且图像的语义信息在投影过程中会有很大损失；而FGU3R通过深度补全网络将图像转换到点云模态</p><p>上述方法都存在从<strong>一个模态投影到另一个模态的过程</strong>，这个操作不可避免地会带来一些<strong>信息损失</strong>：</p><p><img src="/img/image-20250321114742122.png" alt="image-20250321114742122"></p><ul><li>点云投影到相机会损失几何信息，例如深度有关的信息</li><li>图像投影到点云由于数据结构的不一种，密集图像的大量像素点没有相应的点云匹配</li></ul><h4 id="中期融合"><a href="#中期融合" class="headerlink" title="中期融合"></a>中期融合</h4><blockquote><p>中期融合是目前的主流融合方法，通过将两个模态映射到统一空间，并进行特征层级的融合</p></blockquote><p><img src="/img/image-20250321115113767.png" alt="image-20250321115113767"></p><p>BEVFusion通过在模态特定的分支上各自提取特征并将图像和点云都变换到鸟瞰视图进行特征融合，充分保留了几何结构和语义信息</p><h3 id="查询级融合"><a href="#查询级融合" class="headerlink" title="查询级融合"></a>查询级融合</h3><p>受益于transformer系列研究，以query的形式融合模态特征</p><p><img src="/img/image-20250321115607980.png" alt="image-20250321115607980"></p><p><img src="/img/image-20250321115710772.png" alt="image-20250321115710772"></p><p>MV2DFusion通过模态特定的检测分支生成模态特定的查询，最后在query层级通过解码器进行特征融合</p><h3 id="实例级融合"><a href="#实例级融合" class="headerlink" title="实例级融合"></a>实例级融合</h3><p><img src="/img/image-20250321121331461.png" alt="image-20250321121331461"></p><p><img src="/img/image-20250321121541611.png" alt="image-20250321121541611"></p><p>Fully Sparse Fusion通过分割网络对各自模态实现实例级分割，最后再分割是实例上进行基于Transformer架构的融合；而Is-Fusion实现了场景级与实例级的融合，先在全局特征上进行场景级融合，然后生成相应实例并在实力层级进一步进行融合</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="对抗模态失效-鲁棒性问题"><a href="#对抗模态失效-鲁棒性问题" class="headerlink" title="对抗模态失效/鲁棒性问题"></a>对抗模态失效/鲁棒性问题</h4><p>对抗模态失效指的是单一模态失效、模态噪声抑制的情况下，模型性能显著退化，尤其是对于一些依赖于单一模态的架构，如MV3D、Frustum PointNet等。</p><p>一些研究旨在BEV特征融合时进行自适应融合，使得模型自动选取有利特征：</p><p><img src="/img/image-20250321122432083.png" alt="image-20250321122432083"></p><p>GaFusion在BEV特征融合时通过雷达引导，实现自适应特征融合；进一步，ReliFusion通过对每个模态生成置信度分数，加权融合最终特征。</p><p>此外，一些研究引入时空建模解决模态鲁棒性问题：</p><p><img src="/img/image-20250321122817515.png" alt="image-20250321122817515"></p><p>GAFusion通过类似于BEV4D的记忆单元，引入时空特征。</p><h4 id="跨模态对齐"><a href="#跨模态对齐" class="headerlink" title="跨模态对齐"></a>跨模态对齐</h4><p>模态对齐一般指的是几何上的对齐与语义上的对齐，跨模态对齐对于模型性能的相关性显著。</p><p><img src="/img/image-20250321123054263.png" alt="image-20250321123054263"></p><p><img src="/img/image-20250321123321914.png" alt="image-20250321123321914"></p><p>CMT通过将二维、三维的坐标编码引入解码器，实现跨模态的对齐；AutoAlign利用可变形卷积学习从图像特征中采样与点云位置对应的局部区域，从而聚合时自动校准偏差。</p><h4 id="模态信息交互不足"><a href="#模态信息交互不足" class="headerlink" title="模态信息交互不足"></a>模态信息交互不足</h4><p>仅在决策级融合的网络未能让模型在前期就学习到模态间的互补信息，而特征级融合的网络如BEVFusion在生成图像BEV时也忽略了雷达精准几何信息的价值，例如，GAFusion在图像BEV生成的过程中，直接利用点云深度信息。</p><h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><ul><li>不同模态的噪声/不确定性是否可以定量衡量？如何利用定量衡量的噪声平衡不同模态特征的贡献，使模型能在模态失效的情况下仍然能实现较好的性能？</li><li>时空依赖建模仅在最终融合特征/proposal/query交互是否能有效利用不同时间步和不同模态间的信息？是否可以设置局部到全局的时空依赖建模？</li><li>模态对齐过程中，如何实现更好的几何对齐和语义对齐？标定参数是否能够校准？对比学习如何在特定的点云和图像两模态下拉进语义一致性？</li><li><p>如何充分利用模态信息？如何协同多层级的融合机制？点云的深度信息如何辅助图像BEV生成？模态失效的情况下如何惩罚？模态“三原色”理论：冗余信息、模态特定信息、模态协同下的新信息</p></li><li><p>分离时空张量补全能否扩展到多模态融合以应对对抗模态缺失？</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
            <tag> Multi-modal </tag>
            
            <tag> Multi-view </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态目标检测</title>
      <link href="/2025/06/17/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
      <url>/2025/06/17/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多模态目标检测"><a href="#多模态目标检测" class="headerlink" title="多模态目标检测"></a>多模态目标检测</h1><h2 id="MV3D-Multi-View-3D-Object-Detection-Network-for-Autonomous-Driving"><a href="#MV3D-Multi-View-3D-Object-Detection-Network-for-Autonomous-Driving" class="headerlink" title="MV3D: Multi-View 3D Object Detection Network for Autonomous Driving"></a>MV3D: Multi-View 3D Object Detection Network for Autonomous Driving</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MV3D是多模态特征级融合方法，核心思想是建立一个端到端的双阶段的检测网络，核心架构如图所示：</p><p><img src="/img/image-20250303214225824.png" alt="image-20250303214225824"></p><p>首先对三维点云进行预处理投影到二维BV视图和FV视图，分别针对高度、密度、反射强度进行计算。在BV视图中，对高度进行切片，并取cell内的最大值作为相应像素值，因此BV的通道数为M+2;</p><p><img src="/img/image-20250303214307501.png" alt="image-20250303214307501"></p><p>双阶段网络分别：RPN+基于ROIs的Deep Fusion。通过VGG网络提取各模态特征，并仅通过BV视图生成三维提议，三维提议投影到BV、FV、Image平面分别生成对应提议，根据提议从各模态的特征图中截取出ROIs并通过ROI池化进行对齐，通过堆叠的均值融合模块以及分类和回归分支得到最终的预测结果。网络中的上采样操作旨在解决目标尺度过小的问题。在训练过程中，采取drop-path策略和辅助分支损失策略旨在提高模型鲁棒性，使得每种模态分支都能学到鲁棒的表示，避免在某种模态缺失的情况下，模型性能严重下降。</p><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li>连续点云离散到网格平面导致细粒度空间信息丢失</li><li>倾向于点云模态，仅使用BEV进行proposal生成，未能充分利用不同模态的互补信息，尤其是图像模态的丰富语义信息</li><li>均值融合的信息交流不足</li></ul><h2 id="Frustum-PointNets-for-3D-Object-Detection-from-RGB-D-Data"><a href="#Frustum-PointNets-for-3D-Object-Detection-from-RGB-D-Data" class="headerlink" title="Frustum PointNets for 3D Object Detection from RGB-D Data"></a>Frustum PointNets for 3D Object Detection from RGB-D Data</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/img/image-20250304221110837.png" alt="image-20250304221110837"></p><p>Frustum Pointnet首先利用二维检测器从RGB图像检测出二维边界框，并通过投影变换以及传感器预定义深度值得到三维锥体，对三维锥体执行实例分割，近区分前景和背景；实例分割网络利用二维检测器的one-hot分类向量作为语义补充，学习不同类别目标的特有信息；最后对分割出的实例通过Pointnet进行边界框回归。</p><h3 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h3><ul><li>过度依赖二维检测器，若二维检测器检测失败，则无法构建三维锥体，直接检测失败</li><li>未能充分点云的三维几何信息、未能充分利用点云和图像的互补信息</li><li>每个截锥体仅视为一个目标，当目标重叠时无法区分</li></ul><p>研究目标：我希望提升检测精度并减少计算开销；</p><p>我了解的现有方法：在我的研究中，现有的融合方法分为特征级融合和决策级融合，在特征级融合中又分为前、中、后期融合，但都存在一些信息丢失、信息利用不充分、融合带来的噪声信息干扰、不同模态固有噪声带来的不确定性和不平衡性、不同模态数据结构不一致、难对齐等问题，而在决策级融合方法中，存在模态bias的问题，模型倾向于单一模态的信息；此外，object as query的系列方法，如MV2DFusion虽然通过模态独立的分支解决了bias问题，但是query的生成依赖于模态独立的检测器，可能存在不能充分利用模态互补信息的问题。</p><p>新的方法如FGU3R旨在进行模态对齐，通过深度补全网络将图像模态补充深度信息并转化为点云进行统一处理，但是预训练的深度补全网络存在额外开销，整个模型不能实现端到端的训练；</p><p>此外，由于点云的长程稀疏性，现有的方法在远距离检测上效果不佳</p><p>其他相关领域中，开创性的提出纯基于聚类的DVLO模型用于Odemetry任务，旨在解决融合过程中存在的不对齐问题，但是仅使用多尺度特征的融合以及refinement，对于目标检测的迁移需要相关改进；针对文本和图像的情感任务识别等研究着手于拥抱模态不确定性（EAU）来解决模态固有噪声问题。</p><p>数据集：KITTI、nuScene（如需要进行长程任务，则还需要Waymo）</p><p>硬件条件：单卡3080</p><p>模型架构偏好：倾向于改进现有模型</p><p>技术方向：多模态融合、对齐、多尺度融合等</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
            <tag> Multi-modal </tag>
            
            <tag> Multi-view </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MV2DFusion</title>
      <link href="/2024/11/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/MV2DFusion/"/>
      <url>/2024/11/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/MV2DFusion/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>不同模态的传感器能够捕获物体的不同属性，有助于从多模态中识别物体：  </p><ul><li><strong>图像</strong>含有丰富的纹理信息，但缺乏深度信息（相机到图像的投影属于$ill$-$posed$问题）。  </li><li><strong>点云</strong>能够提供精确的三维空间数据，但缺少丰富的语义信息，且由于稀疏性，难以捕捉远距离的物体。<br>为了利用两种模态的优势，提出<strong>多模态融合方法</strong>。传统方法主要分为两类：  </li></ul><ol><li><strong>特征级融合</strong>：将不同模态映射到统一的特征空间（如$BEV$），或通过统一的注意力机制进行聚合，但难以充分挖掘原始模态中的目标先验信息。  </li><li><strong>提议级融合</strong>：先生成各模态的提议，再进行统一融合，但方法往往倾向于单一模态。<br>针对上述不足，提出了<strong>MV2DFusion</strong>，其特点为：  </li></ol><ul><li>充分利用模态特定的语义特点；  </li><li>允许集成任意类型的2D、3D检测器；  </li><li>融合策略具有稀疏性，适用于长距离场景；  </li><li>轻松扩展至4D场景。</li></ul><hr><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a><strong>Related Work</strong></h1><h2 id="LiDAR-based-3D-Detection"><a href="#LiDAR-based-3D-Detection" class="headerlink" title="LiDAR-based 3D Detection"></a><strong>LiDAR-based 3D Detection</strong></h2><ol><li><strong>Point-based</strong>：直接利用3D点云数据进行检测（如<strong>PointCNN</strong>、<strong>3DSSD</strong>、<strong>FSD</strong>）。  </li><li><strong>Voxel-based</strong>：将点云转化为稀疏体素进行处理（如<strong>SECOND</strong>、<strong>CenterPoint</strong>、<strong>Transfusion-L</strong>）。  </li><li><strong>Pillar-based</strong>：将点云投影到2D柱状体平面，使用2D检测方法。  </li><li><strong>Range-based</strong>：将点云映射到2D平面，进行检测。<h2 id="Camera-based-3D-Detection"><a href="#Camera-based-3D-Detection" class="headerlink" title="Camera-based 3D Detection"></a><strong>Camera-based 3D Detection</strong></h2>使用2D检测器的升级版构建3D检测器：  </li></ol><ul><li><strong>CenterNet</strong>  </li><li><strong>FCOS3D</strong>  </li><li><strong>BEV</strong>  </li><li><strong>DETR</strong>  </li><li><strong>MV2D</strong><h2 id="Fusion-based-3D-Detection"><a href="#Fusion-based-3D-Detection" class="headerlink" title="Fusion-based 3D Detection"></a><strong>Fusion-based 3D Detection</strong></h2></li><li><strong>SD-Fusion</strong>  </li><li><strong>BEV</strong>  </li><li><strong>CMT</strong>  </li><li><strong>SparseFusion</strong></li></ul><hr><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a><strong>Motivation</strong></h1><ol><li><strong>多模态信息的互补性</strong> $\Rightarrow$ 模态融合的重要性；  </li><li><strong>特征融合过程中的偏差</strong> $\Rightarrow$ 提议级融合的优化需求；  </li><li><strong>复杂计算开销</strong> $\Rightarrow$ 稀疏策略以降低成本。</li></ol><hr><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a><strong>Methodology</strong></h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>模型接受多视图图像和点云作为输入，经过以下步骤得到3D检测结果：  </p><ol><li>各模态通过独立的特征提取器提取特征，并分别生成2D/3D检测结果；  </li><li>查询生成器生成图像查询和点云查询；  </li><li>在融合解码器中更新查询，整合多模态信息形成最终3D预测。<br>框架示意图如下：<br><img src="/img/MF0.png" alt="framework"><h2 id="模态特定的目标语义"><a href="#模态特定的目标语义" class="headerlink" title="模态特定的目标语义"></a><strong>模态特定的目标语义</strong></h2>通过提取模态特定的目标语义进行多模态检测，保留模态独特优势，同时通过稀疏性降低计算和内存需求。<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a><strong>特征提取</strong></h3></li><li><strong>图像模态</strong>：利用特征金字塔从多视图图像中提取特征集合，通过$ROI$-$Align$对齐（对齐过程中会丢失相机几何信息）。使用任意检测头得到2D检测集合${b_v^{img}}$。  </li><li><strong>点云模态</strong>：采用基于稀疏体素的特征提取网络和检测头，得到3D边界框$b^{pc}$。<h3 id="查询生成"><a href="#查询生成" class="headerlink" title="查询生成"></a><strong>查询生成</strong></h3>基于$Transformer$的查询包含两部分：<strong>内容</strong>和<strong>位置</strong>。<h4 id="点云查询"><a href="#点云查询" class="headerlink" title="点云查询"></a><strong>点云查询</strong></h4>目标的世界坐标作为查询的位置部分，内容部分融合外观特征和几何特征：<script type="math/tex; mode=display">q^{pc} = (c^{pc}, r^{pc}) \tag{1}</script></li></ol><p>其中：</p><script type="math/tex; mode=display">c^{pc} = MLP(o^{pc} + MLP(SinPos(b^{pc}))) \tag{2}</script><h4 id="图像查询"><a href="#图像查询" class="headerlink" title="图像查询"></a><strong>图像查询</strong></h4><p>提出<strong>不确定性感知图像查询</strong>，其内容部分为$RoI$外观特征并嵌入相机内参的几何特征，位置部分用概率分布表示：  </p><script type="math/tex; mode=display">q^{img} = \{ q_v^{img} = (c_v^{img}, s_v^{img}, u_v^{img}) \ | \ 1 \leq v \leq N^{img} \} \tag{3}</script><p>其中：</p><script type="math/tex; mode=display">o_v^{img} = RoI\text{-}Align(F_v^{img}, b_v^{img}) \tag{4}</script><script type="math/tex; mode=display">c_v^{img} = MLP([Pool(Conv(o_v^{img})); Flat(K_v)]) \tag{5}</script><script type="math/tex; mode=display">[s^{2d}; u^{logit}] = MLP(c^{img}) \tag{6}</script><script type="math/tex; mode=display">u^{img} = softmax(u^{logit}) \tag{7}</script><p>结合$s^{2d}$和深度估计，通过相机到真实世界的投影，计算出3D采样位置$S^{img}$。</p><h3 id="模态信息融合"><a href="#模态信息融合" class="headerlink" title="模态信息融合"></a>模态信息融合</h3><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
            <tag> Multi-modal </tag>
            
            <tag> Multi-view </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉</title>
      <link href="/2024/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
      <url>/2024/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 成像原理 </tag>
            
            <tag> 立体重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object as Query:Lifting any 2D Object Detector to 3D Detection</title>
      <link href="/2024/11/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/MV2D/MV2D/"/>
      <url>/2024/11/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/MV2D/MV2D/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>早期的单目视觉方法按照 $2D$ 目标检测 $pipeline$ 进行，不能充分利用周围相机的几何配置和多视图图像信息；采用这些方法进行多视图检测需要复杂的后处理。<br>现有的多视图 $3D$ 目标检测主要分为两个流派：</p><h2 id="密集的3D检测方法"><a href="#密集的3D检测方法" class="headerlink" title="密集的3D检测方法"></a>密集的3D检测方法</h2><p>将多视图投影带三维空间（ $BEV \quad Space$ /体素空间），在高维空间中融合不同视图特征<br>缺陷：高额的计算开销</p><h2 id="稀疏查询检测方法"><a href="#稀疏查询检测方法" class="headerlink" title="稀疏查询检测方法"></a>稀疏查询检测方法</h2><p>利用可学习的 $queries$ 聚合多视图特征以预测最终结果，避免了复杂计算量。<br>缺陷：现有的方法采用固定数量的 $queries$，依赖人类先验，且对于复杂多变的环境缺乏鲁棒性</p><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><h2 id="2D-object-Detection"><a href="#2D-object-Detection" class="headerlink" title="2D object Detection"></a>2D object Detection</h2><ul><li>$RCNN、DETR$</li></ul><h2 id="3D-object-Detection"><a href="#3D-object-Detection" class="headerlink" title="3D object Detection"></a>3D object Detection</h2><ul><li>单视图：边界框 + 额外的深度预测模块</li><li>多视图：$ImVoxelNet、BEV、PETR$</li></ul><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p><img src="/img/image-0.png" alt="motivation"><br>在 $3D$ 检测中固定数量的 $queries$ 错误定位目标或忽略目标，而 $2D$ 检测可以成功的检测出这些目标，如果能有效利用 $2D$ 检测的先验知识，就能有效提高 $2D$ 检测性能。</p><p>因此，作者提出 $MV2D$，利用 $2D$ 检测结果基于丰富的图像语义信息生成 $queries$，这些动态生成的 $queries$ 能有效召回目标，特别是小而远的目标。</p><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/img/image-1.png" alt="framework"><br>给定 $N$ 张视图构成集合，<script type="math/tex">\mathcal{I} = \{ \mathbf{I}_v \mid 0 \leq v < N \}</script>，通过共享权重的特征提取模块和 $2D$ 检测模块分别获得图像特征集合 <script type="math/tex">F = \{ T_v|0\leq v\leq N \}</script>，二维检测结果集合 <script type="math/tex">B = \{ B_v|0\leq v\leq N \}</script>，其中，$F_v\in R^{H_f \times W_f \times C}, B_c\in R^{M_v \times 4}$，$M_v$表示目标数量。</p><p>利用检测结果从图像特征中获取 $ROI$ 区域，并通过 $ROI-Align$ 得到固定长度的特征：$O = { O_v|0\leq v\leq N }, O_v\in R^{M_v \times H^{roi} \times W^{roi} \times C}, O_v = ROI-Align(F_v,B_v)$。</p><p>之后利用 $O、B$ 以及相机内参 $K$、外参 $[R|t]$，通过 $Query \quad Generator$ 生成查询，生成的查询先通过自注意力交互信息，之后通过相关特征选择模块对每一个查询选择相关特征并进行 $cross-attention$，最后通过简单的前馈网络输出预测结果。</p><h2 id="Dynamic-Object-Query-Generation"><a href="#Dynamic-Object-Query-Generation" class="headerlink" title="Dynamic Object Query Generation"></a>Dynamic Object Query Generation</h2><p><img src="/img/image-2.png" alt="Query Generator"><br>具有不同缩放的 $ROI$ 可以视为对应不用的相机内参的透视投影。</p><p>对于 <script type="math/tex">B_v^i = (x_{\text{min}}^i, y_{\text{min}}^i, x_{\text{max}}^i, y_{\text{max}}^i)</script>，等效相机内参:</p><script type="math/tex; mode=display">\mathbf{K}_v^i = \begin{bmatrix}f_x \cdot r_x & 0 & 0 & (o_x - x_{\text{min}}^i) \cdot r_x & 0 \\0 & f_y \cdot r_y & 0 & (o_y - y_{\text{min}}^i) \cdot r_y & 0 \\0 & 0 & 1 & 0 & 0 \\0 & 0 & 0 & 1 & 1 \\\end{bmatrix}</script><p>其中，$r_x=\frac{W^{roi}}{x_max^i-x_min^i},r_y=\frac{H^{roi}}{y_max^i-y_min^i}$，分别表示两个方向的缩放因子。</p><p>上述相机内参包含相机和物体的几何属性，因此采用一个小型网络进行隐式位置编码：<script type="math/tex">p_v^i = H(MLP(Pool(Conv(o_v^i));K_v^i))，p_v^i\in R^4</script> </p><p>$p_v^i$ 可以视为 $ROI$ 中的目标中心坐标，$H$ 表示齐次坐标变换。然后通过相机内外参变化得到真是世界参考坐标：</p><script type="math/tex; mode=display">P_{ref} = \{P_{ref,v}\in R^{M_v \times 3}|0\leq v \leq N \}，其中 P_{ref,v}^i=[R|t]^-1(K_v^i)^-1p_v^i</script><p>最后，通过正余弦编码生成查询集合 <script type="math/tex">Q = \{Q_v\in R^{M_v \times C}|0\leq v\leq N \}</script>，公式如下：</p><script type="math/tex; mode=display">\mathbf{q} = \text{Linear}(PE), \\PE_{[6i:6i+3]} = \sin \left( \frac{p_{\text{ref}}}{10000^{2i / C}} \right), \quad 0 \leq i < C/2, \\PE_{[6i+3:6i+6]} = \cos \left( \frac{p_{\text{ref}}}{10000^{2i / C}} \right), \quad 0 \leq i < C/2</script><h2 id="Relevant-Object-Feature-Selection"><a href="#Relevant-Object-Feature-Selection" class="headerlink" title="Relevant Object Feature Selection"></a>Relevant Object Feature Selection</h2><p><img src="/img/image-3.png" alt="Feature Select"><br>通过仅目标对象的相关区域，可以消除阻碍对象定位性能的干扰因素和噪声，因此作者在 $cross-attention$ 中仅选择与当前 $query$ 对应的其他试图的边界框作为 $k、v$。</p><p>具体而言，对每个查询 $q$，生成一个 $3D$ 的 $meshgrid$，$G\in R^{W^{roi} \times H^{roi} \times D \times 4}$，其中 $g_{x,y,z}=(x \times d_z, y \times d_z, d_z, 1)$，$x、y$ 是 $ROI$ 像素坐标，$d_z$ 是一系列预定于的深度值，$b_v^i$ 就可以转化为 $w$ 视图的坐标。</p><script type="math/tex; mode=display">g^{i}_{v \rightarrow w; x, y, z} = K_w T_{v \rightarrow w} \left( K_v^i \right)^{-1} g_{x, y, z}</script><p>通过投影的点集，计算出最小边界框，然后根据两种策略来选择相关前景区域：</p><ul><li><p>Top1 IoU：</p><script type="math/tex; mode=display">\mathcal{R}_v^i = \left\{ \arg \max_{b_w^j \in B_w} \text{IoU}(b_{v \rightarrow w}^i, b_w^j) \mid v \neq w \right\}</script></li><li><p>All overlapped:</p><script type="math/tex; mode=display">\mathcal{R}_v^i = \left\{ b_w^j \mid \text{IoU}(b_{v \rightarrow w}^i, b_w^j) > 0, \, v \neq w \right\}</script></li></ul><h2 id="Decoder-with-Sparse-Cross-Attention"><a href="#Decoder-with-Sparse-Cross-Attention" class="headerlink" title="Decoder with Sparse Cross Attention"></a>Decoder with Sparse Cross Attention</h2><p>$MV2D$ 仅使用相关特征构建相应查询的 $K、V$，这种设计在提供紧凑键值的同时，防止查询受背景噪音和干扰因素干扰。</p><p>在 $3D$ 对象检测中，预测的对象中心 <script type="math/tex">b_{center} = P_{ref} + b_{offset}</script></p><h2 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h2><p>损失函数结合 $2D$ 检测损失和 $3D$ 检测损失，标签分配按照匈牙利算法进行二分图匹配。</p><p><script type="math/tex">\mathcal{L} = \mathcal{L}_{2d} + \lambda_{3d} \cdot \mathcal{L}_{3d}, 其中 \mathcal{L}_{3d} = \lambda_{cls3d} \cdot \mathcal{L}_{cls3d} + \mathcal{L}_{reg3d}</script>，分类损失和回归损失分别是 $Focal \quad loss$ 和 $L1 \quad loss$。</p><h2 id="Multi-Frame-Input"><a href="#Multi-Frame-Input" class="headerlink" title="Multi-Frame Input"></a>Multi-Frame Input</h2><p>不同时间戳的图像可以视为具有不同相机外参的相机视图，因此 $MV2D$ 可以较容易地处理多帧输入，而无需修改 $pipeline$ ，具有时序优势。</p><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><h2 id="Comparison-with-State-of-the-Arts"><a href="#Comparison-with-State-of-the-Arts" class="headerlink" title="Comparison with State-of-the-Arts"></a>Comparison with State-of-the-Arts</h2><p><img src="/img/image-5.png" alt="val"><br><img src="/img/image-4.png" alt="test"><br>$MV2D-S、MV2D-T$ 分别表示单帧和两帧训练的模型，对比现有的方法达到了SOTA的效果。</p><h2 id="Ablation"><a href="#Ablation" class="headerlink" title="Ablation"></a>Ablation</h2><p><img src="/img/image-6.png" alt="ablation"><br>消融实验选择固定query数量的模型作为 $baseline$，分别研究了 $query$ 数量、生成 $query$ 的方式、特征选择方法以及单双帧的结果，实验表明：</p><ul><li>使用动态生成的查询、双帧、$All \quad Overlapped$ 的方法能达到最优效果</li><li>动态查询优于固定查询，表面利用 $2D$ 先验能有效增强 $3D$ 检测模型</li><li>特定的相关前景特征选择有效增强模型性能</li><li>$multi-frame$ 的时序信息对模型学习有益<br><img src="/img/image-7.png" alt="different query generator"><br>作者继续进行了不同query的生成方式，表面简单的基于采样深度的方法限制了3D定位能力。<br><img src="/img/image-8.png" alt="deformable"><br>$deformable-attention$ 同样能限制 $attention$ 仅在相关特征之间进行，但无法保证覆盖所有相关特征，本文方法克服了上述缺陷，取得更优性能。</li></ul><h2 id="Generalizability-on-Different-2D-Detectors"><a href="#Generalizability-on-Different-2D-Detectors" class="headerlink" title="Generalizability on Different 2D Detectors"></a>Generalizability on Different 2D Detectors</h2><p><img src="/img/image-9.png" alt="2D"><br>作者比较了不同 $2D$ 检测模型对 $3D$ 检测模型效果的影响，表面约优的提议能更好地提升模型性能，展现了模型的泛化性。</p><h2 id="Qualitative-Analysis"><a href="#Qualitative-Analysis" class="headerlink" title="Qualitative Analysis"></a>Qualitative Analysis</h2><p><img src="/img/image-10.png" alt="1"><br>通过透视投影的方法将3D检测结果投影到 $2D$ 平面，以此绘制出 $ROC$ 曲线，表明 $2D$ 检测高效利用图像语义信息来检测物体，并提供给 $3D$ 检测模型充分的物体存在，同时，作者可视化了不同的 $queries$，表明动态生成的查询虽然稀疏，但分布在 $GT$ 周围。<br><img src="/img/image-11.png" alt="2"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文提出的 $MV2D$ 利用 $2D$ 检测目标作为稀疏查询并采用 $sparse \quad cross-attention$ 来约束信息聚合。这种利用 $2D$ 检测结果引导 $3D$ 检测的思想，或将有效促进多视图目标检测的发展。然后，如果在所有视图中都无法检测到目标，可能会导致最终 $3D$ 检测目标的缺失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
            <tag> Multi-view </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点云数据</title>
      <link href="/2024/10/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2024/10/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="点云数据"><a href="#点云数据" class="headerlink" title="点云数据"></a>点云数据</h1><h2 id="什么是点云数据"><a href="#什么是点云数据" class="headerlink" title="什么是点云数据"></a>什么是点云数据</h2><p>点云是点的集合，相较于传统二维图像，点云提供了深度信息，即点云直接提供了三维空间的数据，每一点具有坐标$x,y,z$。</p><h2 id="点云数据获取"><a href="#点云数据获取" class="headerlink" title="点云数据获取"></a>点云数据获取</h2><p>激光雷达$(LiDAR)$、立体视觉</p><h2 id="点云数据特性"><a href="#点云数据特性" class="headerlink" title="点云数据特性"></a>点云数据特性</h2><ul><li>无序性：点的排列不影响数据本身</li><li>近密远疏：激光扫描、视角影响</li><li>非结构化<h2 id="点云任务"><a href="#点云任务" class="headerlink" title="点云任务"></a>点云任务</h2></li><li>点云分割</li><li>点云补全</li><li>点云检测</li><li>分类</li><li>点云生成</li><li>点云配准<h2 id="点云特征"><a href="#点云特征" class="headerlink" title="点云特征"></a>点云特征</h2></li></ul><h2 id="PointNet"><a href="#PointNet" class="headerlink" title="PointNet"></a>PointNet</h2><h3 id="基本出发点"><a href="#基本出发点" class="headerlink" title="基本出发点"></a>基本出发点</h3><p><strong>由于点云的无序性，端到端$(end-to-end)$模型需要具有置换不变性</strong></p><script type="math/tex; mode=display">f(x_1,x_2,...,x_n) = \gamma g(h(x_1),h(x_2),...,h(x_n))</script><p>即将原始特征$MLP$升维后取最大值作为输出特征，再通过$MLP$进行分类。<br><img src="/img/image.png" alt="alt text"><br><strong>没有考虑局部特征融合</strong></p><h3 id="PintNet"><a href="#PintNet" class="headerlink" title="PintNet++"></a>PintNet++</h3><p><strong>基于半径选择局部区域，对区域进行卷积特征提取</strong><br><img src="/img/image2.png" alt="alt text"></p><h4 id="最远点采样"><a href="#最远点采样" class="headerlink" title="最远点采样"></a>最远点采样</h4><script type="math/tex; mode=display">集合U是点云集合，集合A是已采样的点集合，对于B=U-A，计算b \in B，计算d_b=min(d_{ba})，a \in A，最后采样点c=b', d_{b'}=max(d_b)</script><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>由于卷积操作需求，需要固定每个簇内点的数量（少则复制最近，多则删除最远）</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 点云数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点云数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封印序列</title>
      <link href="/2024/08/25/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%81%E5%8D%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2024/08/25/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%81%E5%8D%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="封印序列"><a href="#封印序列" class="headerlink" title="封印序列"></a><a href="https://www.acwing.com/problem/content/5843/">封印序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 $n$ 的非负整数序列 $a_1,a_2,…,a_n$。</p><p>其中的所有元素将被逐个封印。</p><p>具体封印顺序可以用一个 $1∼n$ 的排列 $b_1,b_2,…,b_n$描述;</p><p>第 $i$ 个被封印的元素即为 $a_{bi}$ 。</p><p>你需要完成 $n$ 个任务（编号 $1∼n$），其中第 $i$ 个任务是：对于完成前 $i$ 次封印的序列，请你找到序列中的一个连续子序列（可以为空），使得该子序列不含任何被封印的元素，且子序列内各元素之和尽可能大，输出这个子序列元素和的最大可能值。</p><p>空序列的元素和视为 $0$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含整数 $n$。</p><p>第二行包含 $a_1,a_2,…,a_n$。</p><p>第三行包含 $b_1,b_2,…,b_n$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 $n$ 行，第 $i$ 行输出第 $i$ 个任务的结果。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>前 $4$ 个测试点满足 $1\leq n\leq 10$。<br>所有测试点满足 $1\leq n\leq 1e5，0\leq a_i\leq 1e9，b_1∼b_n$ 是一个 $1∼n$ 的排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入样例1：</span><br><span class="line">4</span><br><span class="line">1 3 2 5</span><br><span class="line">3 4 1 2</span><br><span class="line">输出样例1：</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">输入样例2：</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">4 2 3 5 1</span><br><span class="line">输出样例2：</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">输入样例3：</span><br><span class="line">8</span><br><span class="line">5 5 4 4 6 6 5 5</span><br><span class="line">5 2 8 7 1 3 4 6</span><br><span class="line">输出样例3：</span><br><span class="line">18</span><br><span class="line">16</span><br><span class="line">11</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从左往右为封印一个元素，从右往左则为插入一个元素，故本体可以视为不断插入元素，求取最大子段和。<br>插入一个元素有三种可能，孤立/与左边相连/与右边相连，容易想到可以用并查集来维护；<br>这里采取的序列并查集较为特殊，每个区间以右端点为代表节点（父节点）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N],p[N]; <span class="comment">//分别记录元素、删除顺序、并查集</span></span><br><span class="line">LL ans[N],s[N]; <span class="comment">//ans记录每次的最大字段和、s记录最大值</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//st判断插入与否</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i ; -- i) &#123;</span><br><span class="line">        <span class="type">int</span> k = b[i];</span><br><span class="line">        st[k] = <span class="literal">true</span>, s[k] = a[k];</span><br><span class="line">        <span class="keyword">if</span>(st[k+<span class="number">1</span>]) s[<span class="built_in">find</span>(k+<span class="number">1</span>)] += s[k], p[k] = <span class="built_in">find</span>(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(st[k<span class="number">-1</span>]) s[<span class="built_in">find</span>(k)] += s[k<span class="number">-1</span>], p[k<span class="number">-1</span>] = <span class="built_in">find</span>(k);</span><br><span class="line">        ans[i<span class="number">-1</span>] = <span class="built_in">max</span>(ans[i],s[<span class="built_in">find</span>(k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spatial Transformer Network</title>
      <link href="/2024/07/11/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/STN/"/>
      <url>/2024/07/11/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/STN/</url>
      
        <content type="html"><![CDATA[<h1 id="Spatial-Transformer-Network-STN"><a href="#Spatial-Transformer-Network-STN" class="headerlink" title="Spatial Transformer Network(STN)"></a>Spatial Transformer Network(STN)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><hr><p><strong>CNN is not invariant for scaling and rotaion.</strong></p><hr><p>STN核心由<strong>localization网络、网络生成器、网络采样器</strong>组成：</p><p>localization一般有卷积层和全连接层组成，用以学习仿射变换参数$\theta$；</p><p>网络生成器根据学习到的$/theta$建立从输出到输入的坐标映射网络$T_{\theta}$；</p><p>网络采样器通过插值的方法计算输出图像每个像素的像素值。</p><p><img src="/img/STN.png" alt="image.png"></p><hr><p>STN的突出优点是<strong>不需要矫正的标签</strong>进行训练，而是自适应学习最优的空间变换，以便于网络的后续部分更好的处理数据。</p><h2 id="Code-based-digit-recognition"><a href="#Code-based-digit-recognition" class="headerlink" title="Code based digit recognition"></a>Code based digit recognition</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  <span class="comment"># 即使在python2.X，使用print就得像python3.X那样加括号使用</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="comment"># Training dataset</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(root=<span class="string">&#x27;.&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                   ])), batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Test dataset</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(root=<span class="string">&#x27;.&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])), batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立手写数字识别模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># in_channel, out_channel, kennel_size</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2_drop = nn.Dropout2d()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">320</span>, <span class="number">50</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Spatial transformer localization-network</span></span><br><span class="line">        <span class="comment"># 其实这里的localization-network也只是一个普通的CNN+全连接层</span></span><br><span class="line">        <span class="comment"># nn.Conv2d前几个参数为in_channel, out_channel, kennel_size, stride=1, padding=0</span></span><br><span class="line">        <span class="comment"># nn.MaxPool2d前几个参数为kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False</span></span><br><span class="line">        self.localization = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">8</span>, kernel_size=<span class="number">7</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">8</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Regressor for the 3 * 2 affine matrix</span></span><br><span class="line">        self.fc_loc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">10</span> * <span class="number">3</span> * <span class="number">3</span>, <span class="number">32</span>),  <span class="comment"># in_features, out_features, bias = True</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">32</span>, <span class="number">3</span> * <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize the weights/bias with identity transformation</span></span><br><span class="line">        self.fc_loc[<span class="number">2</span>].weight.data.zero_()</span><br><span class="line">        self.fc_loc[<span class="number">2</span>].bias.data.copy_(torch.tensor([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=torch.<span class="built_in">float</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Spatial transformer network forward function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stn</span>(<span class="params">self, x</span>):</span><br><span class="line">        xs = self.localization(x)  <span class="comment"># 先进入localization层</span></span><br><span class="line">        xs = xs.view(-<span class="number">1</span>, <span class="number">10</span> * <span class="number">3</span> * <span class="number">3</span>)  <span class="comment"># 展开为向量</span></span><br><span class="line">        theta = self.fc_loc(xs)  <span class="comment"># 进入全连接层，得到theta向量</span></span><br><span class="line">        theta = theta.view(-<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 对theta向量进行resize操作，输出2*3的仿射变换矩阵,通道数为C</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># affine_grid函数的输入中，theta的格式为(N,2,3)，size参数的格式为(N,C,W&#x27;,H&#x27;)</span></span><br><span class="line">        <span class="comment"># affine_grid函数中得到的输出grid的大小为(N,H,W,2)，这里的2是因为一个点的坐标需要x和y两个数来描述</span></span><br><span class="line">        grid = F.affine_grid(theta=theta, size=x.size())  <span class="comment"># 这里size参数为输出图像的大小，和输入一样，因此采取x.size</span></span><br><span class="line">        <span class="comment"># grid_sample函数的输入中，x代表ST的输入图，格式为(N,C,W,H),W&#x27;可以不等于W,H‘可以不等于H;grid是上一步得到的</span></span><br><span class="line">        x = F.grid_sample(x, grid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># transform the input</span></span><br><span class="line">        x = self.stn(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform the usual forward pass</span></span><br><span class="line">        x = F.relu(F.max_pool2d(self.conv1(x), <span class="number">2</span>))</span><br><span class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">320</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, target = data.to(device), target.to(device)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.nll_loss(output, target)  <span class="comment"># 前面用的是log_softmax，因此这里用nll_loss</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        test_loss = <span class="number">0</span></span><br><span class="line">        correct = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, target = data.to(device), target.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># sum up batch loss</span></span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">&#x27;sum&#x27;</span>).item()</span><br><span class="line">            <span class="comment"># get the index of the max log-probability</span></span><br><span class="line">            pred = output.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.view_as(pred)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">        test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span></span><br><span class="line">              .<span class="built_in">format</span>(test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">                      <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_image_np</span>(<span class="params">inp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Convert a Tensor to numpy image.&quot;&quot;&quot;</span></span><br><span class="line">    inp = inp.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    inp = std * inp + mean <span class="comment">#逆正则化</span></span><br><span class="line">    inp = np.clip(inp, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> inp</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to visualize the output of the spatial transformers layer</span></span><br><span class="line"><span class="comment"># after the training, we visualize a batch of input images and</span></span><br><span class="line"><span class="comment"># the corresponding transformed batch using STN.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_stn</span>():</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># Get a batch of training data</span></span><br><span class="line">        data = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_loader))[<span class="number">0</span>].to(device)</span><br><span class="line"></span><br><span class="line">        input_tensor = data.cpu()</span><br><span class="line">        transformed_input_tensor = model.stn(data).cpu()</span><br><span class="line"></span><br><span class="line">        in_grid = convert_image_np(</span><br><span class="line">            torchvision.utils.make_grid(input_tensor))</span><br><span class="line"></span><br><span class="line">        out_grid = convert_image_np(</span><br><span class="line">            torchvision.utils.make_grid(transformed_input_tensor))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot the results side-by-side</span></span><br><span class="line">        f, axarr = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        axarr[<span class="number">0</span>].imshow(in_grid)</span><br><span class="line">        axarr[<span class="number">0</span>].set_title(<span class="string">&#x27;Dataset Images&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        axarr[<span class="number">1</span>].imshow(out_grid)</span><br><span class="line">        axarr[<span class="number">1</span>].set_title(<span class="string">&#x27;Transformed Images&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span> + <span class="number">1</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Visualize the STN transformation on some input batch</span></span><br><span class="line">    visualize_stn()</span><br><span class="line"></span><br><span class="line">    plt.ioff()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>下图展示了STN处理后的图像变化结果：<br><img src="/img/minist.png" alt="minist"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仿射变换 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dataset</title>
      <link href="/2024/07/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/dataset/"/>
      <url>/2024/07/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/dataset/</url>
      
        <content type="html"><![CDATA[<h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><p>Dataset类是torch中的一个常用的用于数据数据集读取的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_dir = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,idx</span>):</span><br><span class="line">        img_name = self.img_dir[idx]</span><br><span class="line">        img_item_pth = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_pth)</span><br><span class="line">        img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root_dir = <span class="string">&#x27;Data/hymenoptera_data/train&#x27;</span></span><br><span class="line">    ants_dir = <span class="string">&#x27;ants&#x27;</span></span><br><span class="line">    bees_dir = <span class="string">&#x27;bees&#x27;</span></span><br><span class="line">    ants = MyDataset(root_dir, ants_dir)</span><br><span class="line">    bees = MyDataset(root_dir, bees_dir)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> torch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值法</title>
      <link href="/2024/06/03/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%8F%92%E5%80%BC%E6%B3%95/"/>
      <url>/2024/06/03/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%8F%92%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>图像是由像素构成的，在对图像进行放大的过程中，未知区域的像素值通过原图像计算得到。</p><h2 id="坐标对应公式"><a href="#坐标对应公式" class="headerlink" title="坐标对应公式"></a>坐标对应公式</h2><script type="math/tex; mode=display">x = x^{'} \times \frac{w}{w^{'}}</script><script type="math/tex; mode=display">y = y^{'} \times \frac{h}{h^{'}}</script><p>$x,y$：原图像的像素坐标<br>$x^{‘},y^{‘}$：放大后的图像坐标<br>$w,h$：图像的宽、高<br>$w^{‘},h^{‘}$：放大后的图像宽高</p><h2 id="最近邻插值法"><a href="#最近邻插值法" class="headerlink" title="最近邻插值法"></a>最近邻插值法</h2><p>直接将与$x,y$最近的坐标的像素值赋给$x^{‘},y^{‘}$。</p><h2 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h2><p>基于线性关系，通过三次单线性插值得到像素值。</p><p><img src="/img/img1.png" alt="单线性插值"></p><script type="math/tex; mode=display">\frac{y-y_1}{x-x_1} = \frac{y_2-y_1}{x_2-x_1}</script><p>经过简单整理得到：</p><script type="math/tex; mode=display">y = \frac{x_2 - x}{x_2-x1} \times x_1 + \frac{x-x_1}{x_2-x_1} \times y_2</script><p><img src="/img/img2.png" alt="双线性插值"></p><p>具体步骤：</p><p>对<script type="math/tex">Q_{12},Q_{22}</script>（横轴方向）平面进行单线性插值得到$R_2$，同理得到$R_1$</p><p>最后对$R_1,R_2$（纵轴方向）平面再进行一次单线性插值，就得到$P$</p><p>注意到$x_2 - x1 = 1$，$y_2 - y_1 = 1$，那么通过简单计算：</p><script type="math/tex; mode=display">f(x,y) = f(Q_{11})(x_2-x)(y_2-y) + f(Q_{21})(x - x_1)(y_2-y) + f(Q_{12})(x_2 - x)(y - y_1) + f(Q_{22})(x - x_1)(y - y_1)</script>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插值法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析课程综合复习</title>
      <link href="/2024/05/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%BB%BC%E5%90%88%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/05/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%E7%BB%BC%E5%90%88%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-迭代法"><a href="#第三章-迭代法" class="headerlink" title="第三章 迭代法"></a>第三章 迭代法</h1><h2 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">            a[i][j] = a[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; dist;</span><br><span class="line">    <span class="type">int</span> dis = <span class="number">500</span>,oil = <span class="number">500</span>,cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(dis &lt; dist) &#123;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dis &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; oil &lt;&lt; endl;</span><br><span class="line">        ++cnt;</span><br><span class="line">        dis += <span class="number">500</span>/(<span class="number">2</span> * cnt - <span class="number">1</span>);</span><br><span class="line">        oil += <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis = dist - (dis - <span class="number">500</span>/(<span class="number">2</span> * cnt - <span class="number">1</span>));</span><br><span class="line">    oil = oil - <span class="number">500</span> + dis * (<span class="number">2</span> * cnt - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dis &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; oil &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循坏置换"><a href="#循坏置换" class="headerlink" title="循坏置换"></a>循坏置换</h2><h3 id="原始"><a href="#原始" class="headerlink" title="原始"></a>原始</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:<span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">gcd</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i],p = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / q; ++ j) &#123;</span><br><span class="line">            p = (p + k) % n;</span><br><span class="line">            <span class="built_in">swap</span>(a[p],tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:<span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">gcd</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++ i) &#123;</span><br><span class="line">        p1 = (i + (n/q - <span class="number">1</span>) * k) % n;</span><br><span class="line">        <span class="type">int</span> temp = a[p1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n/q - <span class="number">2</span>; j &gt;= <span class="number">0</span>; -- j) &#123;</span><br><span class="line">            p2 = (i + j * k) % n;</span><br><span class="line">            a[p1] = a[p2];</span><br><span class="line">            p1 = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        a[p2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> d,i,j,len;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= len; ++ j) &#123;</span><br><span class="line">            b = a[j] * i;</span><br><span class="line">            a[j] = b % <span class="number">1000000</span>;</span><br><span class="line">            d = b / <span class="number">1000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d) a[j] = d, ++ len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i) cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方程近似解"><a href="#方程近似解" class="headerlink" title="方程近似解"></a>方程近似解</h2><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1 = <span class="number">0.4</span>,x0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(x1 - x0) &gt; eps) &#123;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        x1 = <span class="built_in">sqrt</span>(<span class="built_in">sin</span>(x0) + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1 = <span class="number">0</span>,x2 = <span class="number">1</span>,x = <span class="number">0</span>,x3 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">9</span> * x1 * x1 - <span class="built_in">sin</span>(x1) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">9</span> * x2 * x2 - <span class="built_in">sin</span>(x2) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f1 * f2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>(x - x3) &gt; eps) &#123;</span><br><span class="line">            x = (x1 + x2) / <span class="number">2</span>;</span><br><span class="line">            f = <span class="number">9</span> * x * x - <span class="built_in">sin</span>(x) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(f * f1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x3 = x1;</span><br><span class="line">                f1 = f;</span><br><span class="line">                x1 = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                x3 = x2;</span><br><span class="line">                f2 = f;</span><br><span class="line">                x2 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">double</span> x1,x2;</span><br><span class="line">   cin &gt;&gt; x1;</span><br><span class="line">   x2 = x1 - (<span class="number">9</span> * x1 * x1 - <span class="built_in">sin</span>(x1) - <span class="number">1</span>) / (<span class="number">18</span> * x1 - <span class="built_in">cos</span>(x1));</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">abs</span>(x1 - x2) &gt; eps)&#123;</span><br><span class="line">       x1 = x2;</span><br><span class="line">       x2 = x1 - (<span class="number">9</span> * x1 * x1 - <span class="built_in">sin</span>(x1) - <span class="number">1</span>) / (<span class="number">18</span> * x1 - <span class="built_in">cos</span>(x1));</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-蛮力法"><a href="#第四章-蛮力法" class="headerlink" title="第四章 蛮力法"></a>第四章 蛮力法</h1><h2 id="链对"><a href="#链对" class="headerlink" title="链对"></a>链对</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> x1,x2;</span><br><span class="line">    cin &gt;&gt; x1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; x2;</span><br><span class="line">        a[x1][x2] ++ ;</span><br><span class="line">        x1 = x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] &amp;&amp; a[j][i]) </span><br><span class="line">                <span class="keyword">if</span>(i != j) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) = %d,(%d,%d) = %d\n&quot;</span>,i,j,a[i][j],j,i,a[j][i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">if</span>(a[i][j] &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) = %d\n&quot;</span>,i,j,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造数字"><a href="#构造数字" class="headerlink" title="构造数字"></a>构造数字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">3</span>; a &lt; <span class="number">10</span>; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>; d &lt; <span class="number">10</span>; ++ d) &#123;</span><br><span class="line">            <span class="type">int</span> td = d * <span class="number">100000</span> + d * <span class="number">10000</span> + d * <span class="number">1000</span> + d * <span class="number">100</span> + d * <span class="number">10</span> + d;</span><br><span class="line">            <span class="keyword">if</span>(td % a == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> f = td / a;</span><br><span class="line">                <span class="keyword">if</span>((f/<span class="number">10000</span> == a) &amp;&amp; (f/<span class="number">10</span>%<span class="number">10</span>==a) &amp;&amp; (f%<span class="number">10</span>==f/<span class="number">1000</span>%<span class="number">10</span>))</span><br><span class="line">                    cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; td &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="玫瑰矩阵"><a href="#玫瑰矩阵" class="headerlink" title="玫瑰矩阵"></a>玫瑰矩阵</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>,i = n,t = <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">-1</span>,s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n * n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> hc = <span class="number">1</span>; hc &lt; <span class="number">2</span> * i;++ hc) &#123;</span><br><span class="line">            <span class="type">int</span> index = hc / (i + <span class="number">1</span>);</span><br><span class="line">            s[index] += t;</span><br><span class="line">            a[s[<span class="number">0</span>]][s[<span class="number">1</span>]] = k++;</span><br><span class="line">        &#125;</span><br><span class="line">        -- i,t = <span class="number">0</span> - t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旅行商"><a href="#旅行商" class="headerlink" title="旅行商"></a>旅行商</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> mn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i )</span><br><span class="line">        sum += g[a[i<span class="number">-1</span>]][a[i]];</span><br><span class="line">    sum += g[a[n<span class="number">-1</span>]][a[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        path[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mn &gt; <span class="built_in">cost</span>()) mn = <span class="built_in">cost</span>(),<span class="built_in">copy</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = u; k &lt; n; ++ k) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[k],a[u]);</span><br><span class="line">        <span class="built_in">solve</span>(u+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[k],a[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i] = i;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">bool</span> vis[N],bags[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cur_v,<span class="type">int</span> cur_w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_w &gt; c) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; cur_v) &#123;</span><br><span class="line">            res = cur_v;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) bags[i] = vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur_v+v[u+<span class="number">1</span>],cur_w+w[u+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur_v,cur_w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(bags[i]) cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-分治法"><a href="#第五章-分治法" class="headerlink" title="第五章 分治法"></a>第五章 分治法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,tar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; tar;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= tar) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[r] == tar) cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN(A) ((A &gt; 0)?1:-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x,y,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x * y;</span><br><span class="line">    <span class="type">int</span> x1 = x/<span class="built_in">pow</span>(<span class="number">10</span>,n/<span class="number">2</span>),y1 = y/<span class="built_in">pow</span>(<span class="number">10</span>,n/<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> x0 = x - x1 * <span class="built_in">pow</span>(<span class="number">10</span>,n/<span class="number">2</span>),y0 = y - y1 * <span class="built_in">pow</span>(<span class="number">10</span>,n/<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> xy1 = <span class="built_in">mul</span>(x1,y1,n/<span class="number">2</span>),xy0 = <span class="built_in">mul</span>(x0,y0,n/<span class="number">2</span>),xy10 = <span class="built_in">mul</span>(x1-x0,y0-y1,n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> xy1 * <span class="built_in">pow</span>(<span class="number">10</span>,n) + (xy10 + xy0 + xy1) * <span class="built_in">pow</span>(<span class="number">10</span>,n/<span class="number">2</span>) + xy0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">SIGN</span>(x) * <span class="built_in">SIGN</span>(y);</span><br><span class="line">    <span class="type">int</span> res = s * <span class="built_in">mul</span>(<span class="built_in">abs</span>(x),<span class="built_in">abs</span>(y),n);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第k小元素"><a href="#第k小元素" class="headerlink" title="第k小元素"></a>第k小元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> i = l,j = r,pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= pivot) ++ i;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt; pivot) -- j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)  <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = a[j],a[j] = pivot;</span><br><span class="line">    <span class="keyword">if</span>(j - l + <span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j - l + <span class="number">1</span> &gt; k) <span class="keyword">return</span> <span class="built_in">get</span>(l,j<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(j+<span class="number">1</span>,r,k-j<span class="number">-1</span>+l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>(<span class="number">1</span>,n,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">max</span>(<span class="built_in">f</span>(l,m),<span class="built_in">f</span>(m+<span class="number">1</span>,r));</span><br><span class="line">    <span class="type">int</span> mxl,mxr;</span><br><span class="line">    mxl = mxr = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> sl = <span class="number">0</span>,sr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= l; -- i) &#123;</span><br><span class="line">        sl += a[i];</span><br><span class="line">        mxl = <span class="built_in">max</span>(mxl,sl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m + <span class="number">1</span>; i &lt;= r; ++ i) &#123;</span><br><span class="line">        sr += a[i];</span><br><span class="line">        mxr = <span class="built_in">max</span>(mxr,sr);</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res,mxl + mxr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">f</span>(<span class="number">1</span>,n);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N],maxx[N];</span><br><span class="line"><span class="type">int</span> n,c,res,r;</span><br><span class="line"><span class="type">int</span> w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt; c) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; cur) &#123;</span><br><span class="line">            res = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) maxx[i] = vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur + w[u+<span class="number">1</span>]);</span><br><span class="line">    vis[u+<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur + s[n] - s[u+<span class="number">1</span>] &gt; res) <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(maxx[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N-皇后问题"><a href="#N-皇后问题" class="headerlink" title="N-皇后问题"></a>N-皇后问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; u; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(x[i] == x[u] || <span class="built_in">abs</span>(x[i] - x[u]) == <span class="built_in">abs</span>(i-u))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n) &#123;</span><br><span class="line">        cout &lt;&lt; ++ cnt &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,i,x[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        x[u] = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(u)) <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],v[N],s[N];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">bool</span> vis[N], maxx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cur_w,<span class="type">int</span> cur_v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_w &gt; c) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; cur_v) &#123;</span><br><span class="line">            res = cur_v;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) maxx[i] = vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur_w + w[u+<span class="number">1</span>],cur_v + v[u+<span class="number">1</span>]);</span><br><span class="line">    vis[u+<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur_v + s[n] - s[u+<span class="number">1</span>] &gt; res) <span class="built_in">dfs</span>(u+<span class="number">1</span>,cur_w,cur_v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h3 id="装载问题-1"><a href="#装载问题-1" class="headerlink" title="装载问题"></a>装载问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(w[<span class="number">1</span>] &lt; c) q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,w[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> ssize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ssize; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            res = <span class="built_in">max</span>(res,t.w);</span><br><span class="line">            <span class="keyword">if</span>(t.i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t.w + w[t.i + <span class="number">1</span>] &lt;= c) q.<span class="built_in">push</span>(&#123;t.i+<span class="number">1</span>,t.w + w[t.i + <span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(t.w + s[n] - s[t.i + <span class="number">1</span>] &gt; res) q.<span class="built_in">push</span>(&#123;t.i+<span class="number">1</span>,t.w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bestv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,weight;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t1[N],t2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">msort</span>(l,mid),<span class="built_in">msort</span>(mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i = l,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] * <span class="number">1.0</span> / w[i] &gt;= v[j] * <span class="number">1.0</span> / w[j]) t1[k] = v[i],t2[k++] = w[i ++];</span><br><span class="line">        <span class="keyword">else</span> t1[k] = v[j],t2[k++] = w[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) t1[k] = v[i],t2[k++] = w[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) t1[k] = v[j],t2[k++] = w[j ++];</span><br><span class="line">    <span class="keyword">for</span>(i = l,k = <span class="number">0</span>; i &lt;= r; ++ i, ++ k) v[i] = t1[k],w[i] = t2[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i * w[u] &lt;= c; ++ i) &#123; </span><br><span class="line">        q.<span class="built_in">push</span>(&#123;v[u] * i,w[u] * i&#125;);</span><br><span class="line">        bestv = <span class="built_in">max</span>(v[u] * i,bestv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">        ++ u;</span><br><span class="line">        <span class="keyword">if</span>(u == n + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = c - t.weight;</span><br><span class="line">            <span class="keyword">if</span>(t.val + left * v[u] * <span class="number">1.0</span> / w[u] &lt;= bestv) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; t.weight + w[u] * i &lt;= c; ++ i) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;t.val + v[u] * i,t.weight + w[u] * i&#125;);</span><br><span class="line">                bestv = <span class="built_in">max</span>(bestv,t.val + v[u] * i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">msort</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; bestv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章-贪心算法"><a href="#第七章-贪心算法" class="headerlink" title="第七章 贪心算法"></a>第七章 贪心算法</h1><p><strong>最优子结构</strong></p><h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Act</span>&#123;</span><br><span class="line">    <span class="type">int</span> s,e;</span><br><span class="line">    <span class="type">bool</span> sel;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Act &amp;p) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e &lt; p.e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;act[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin &gt;&gt; act[i].s &gt;&gt; act[i].e;</span><br><span class="line">    <span class="built_in">sort</span>(act + <span class="number">1</span>,act + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> st = act[<span class="number">1</span>].s,ed = act[<span class="number">1</span>].e;</span><br><span class="line">    act[<span class="number">1</span>].sel = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(act[i].s &gt;= ed)</span><br><span class="line">            ++ cnt,st = act[i].s,ed = act[i].e,act[i].sel = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(act[i].sel)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="极大值极小值"><a href="#极大值极小值" class="headerlink" title="极大值极小值"></a>极大值极小值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mx,mn;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        mx.<span class="built_in">insert</span>(-a),mn.<span class="built_in">insert</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = *mx.<span class="built_in">begin</span>();mx.<span class="built_in">erase</span>(mx.<span class="built_in">find</span>(a));</span><br><span class="line">        <span class="type">int</span> b = *mx.<span class="built_in">begin</span>();mx.<span class="built_in">erase</span>(mx.<span class="built_in">find</span>(b));</span><br><span class="line">        <span class="type">int</span> c = *mn.<span class="built_in">begin</span>();mn.<span class="built_in">erase</span>(mn.<span class="built_in">find</span>(c));</span><br><span class="line">        <span class="type">int</span> d = *mn.<span class="built_in">begin</span>();mn.<span class="built_in">erase</span>(mn.<span class="built_in">find</span>(d));</span><br><span class="line">        a = <span class="number">0</span> - a,b = <span class="number">0</span> - b;</span><br><span class="line">        a = a * b + <span class="number">1</span>;</span><br><span class="line">        c = c * d + <span class="number">1</span>;</span><br><span class="line">        mx.<span class="built_in">insert</span>(-a);mn.<span class="built_in">insert</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> -*mx.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *mn.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数字"><a href="#删除数字" class="headerlink" title="删除数字"></a>删除数字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">char</span> *a,<span class="type">int</span> t,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt; <span class="built_in">strlen</span>(a) - k; ++ i)</span><br><span class="line">        a[i] = a[i + k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s &amp;&amp; j &lt; <span class="built_in">strlen</span>(a)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &lt;= a[j + <span class="number">1</span>]) ++ j;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="built_in">strlen</span>(a)) &#123;</span><br><span class="line">            <span class="built_in">del</span>(a,j,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= last) d[i] = j + i;</span><br><span class="line">            <span class="keyword">else</span> d[i] = d[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">            last = j; ++ i,-- j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">strlen</span>(a)) <span class="built_in">del</span>(a,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - s; ++ i) cout &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-动态规划"><a href="#第八章-动态规划" class="headerlink" title="第八章 动态规划"></a>第八章 动态规划</h1><p><strong>最优子结构、子问题重叠性</strong></p><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N],f[N][N];</span><br><span class="line"><span class="type">int</span> path[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">/*for(int i = 0; i &lt;= n; ++ i) </span></span><br><span class="line"><span class="comment">        for(int j = 0; j &lt;= n + 1; ++ j)</span></span><br><span class="line"><span class="comment">            f[i][j] = -inf;*/</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) f[n][i] = a[n][i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(f[i + <span class="number">1</span>][j] &gt; f[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">                path[i][j] = <span class="number">0</span>,f[i][j] = f[i + <span class="number">1</span>][j] + a[i][j];</span><br><span class="line">            <span class="keyword">else</span> path[i][j] = <span class="number">1</span>,f[i][j] = f[i + <span class="number">1</span>][j + <span class="number">1</span>] + a[i][j];</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,a[i][j]);</span><br><span class="line">        j += path[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[n][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="投资分配"><a href="#投资分配" class="headerlink" title="投资分配"></a>投资分配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N],g[N],t[N];</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> gain[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; f[i];</span><br><span class="line">        g[i] = f[i];</span><br><span class="line">        a[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            t[j] = g[j];</span><br><span class="line">            cin &gt;&gt; f[j];</span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; ++ k)</span><br><span class="line">                <span class="keyword">if</span>(f[k] + g[j - k] &gt; t[j])</span><br><span class="line">                    t[j] = f[k] + g[j - k],a[i][j] = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">            g[i] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">        gain[i] = a[i][res],res -= gain[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) cout &lt;&lt; gain[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; g[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">bool</span> bag[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] &gt; f[i<span class="number">-1</span>][j]) bag[i] = <span class="literal">true</span>,j -= w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(bag[i]) cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N],m[N][N],s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d): %d\n&quot;</span>,l,r,s[l][r]);</span><br><span class="line">    <span class="built_in">output</span>(l,s[l][r]),<span class="built_in">output</span>(s[l][r] + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; ++ i) cin &gt;&gt; p[i];</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++ len)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; ++ k) &#123;</span><br><span class="line">                <span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i] * p[k+<span class="number">1</span>] * p[j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(t &lt; m[i][j]) m[i][j] = t,s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">output</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a + <span class="number">1</span>,b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和-1"><a href="#最大子段和-1" class="headerlink" title="最大子段和"></a>最大子段和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,cur = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> st,ed;</span><br><span class="line">    st = ed = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n;++ j) &#123;</span><br><span class="line">        cur += a[j];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; res) res = cur,st = i,ed = j;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span>) i = j + <span class="number">1</span>,cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ed &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第九章-随机算法"><a href="#第九章-随机算法" class="headerlink" title="第九章 随机算法"></a>第九章 随机算法</h1><h2 id="线性同余生成伪随机"><a href="#线性同余生成伪随机" class="headerlink" title="线性同余生成伪随机"></a>线性同余生成伪随机</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> b = <span class="number">1194211693l</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> c = <span class="number">12345l</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> rand_seed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mysrand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seed)</span></span>&#123;</span><br><span class="line">    rand_seed = seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">myrand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rand_seed = (rand_seed * b + c) % ((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> rand_seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">myrandf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand_seed * <span class="number">1.0</span>/((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">mysrand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++ i) &#123;</span><br><span class="line">        <span class="built_in">myrand</span>();</span><br><span class="line">        cout &lt;&lt; rand_seed &lt;&lt; endl &lt;&lt; <span class="built_in">myrandf</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        x = <span class="built_in">rand</span>() * <span class="number">1.0</span> / RAND_MAX;</span><br><span class="line">        y = <span class="built_in">rand</span>() * <span class="number">1.0</span> / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span>(x * x + y * y &lt;= <span class="number">1</span>) ++ cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> * cnt * <span class="number">1.0</span> / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> n)</span>  <span class="comment">// 求a^k mod p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">1</span>,z = a;</span><br><span class="line">   <span class="keyword">while</span>(k)&#123;</span><br><span class="line">       <span class="keyword">while</span>(k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> x = z;</span><br><span class="line">           z = z * z % n;</span><br><span class="line">           k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//if((z == 1) &amp;&amp; (x != 1) &amp;&amp; (x != n - 1)) return true;</span></span><br><span class="line">       &#125;</span><br><span class="line">       -- k;</span><br><span class="line">       y = y * z % n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">log10</span>(n); ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rand</span>() % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qmi</span>(a,n<span class="number">-1</span>,n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prime</span>(n)) cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="舍伍德算法"><a href="#舍伍德算法" class="headerlink" title="舍伍德算法"></a>舍伍德算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> i = l,j = l + <span class="built_in">rand</span>() % (r - l);</span><br><span class="line">    <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    j = r;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= pivot) ++ i;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt; pivot) -- j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)  <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = a[j],a[j] = pivot;</span><br><span class="line">    <span class="keyword">if</span>(j - l + <span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j - l + <span class="number">1</span> &gt; k) <span class="keyword">return</span> <span class="built_in">get</span>(l,j<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(j+<span class="number">1</span>,r,k-j<span class="number">-1</span>+l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>(<span class="number">1</span>,n,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/04/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/04/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树类似于一颗完全二叉树，其结点形式化定义为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;    <span class="comment">//区间的左端点、右端点</span></span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">//要维护的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>线段树主要涉及$5$个核心操作：</p><ul><li>建树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[u] = &#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="comment">// 建立相关信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pushup</li></ul><p><strong>用子树信息更新根节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].v = (tr[u &lt;&lt; <span class="number">1</span>],tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);     <span class="comment">//视具体情况而定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pushdown</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">* 查询</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="built_in">query</span>(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l = x &amp;&amp; tr[u].r == x) <span class="comment">//修改u</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>,x,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间最大公约数"><a href="#区间最大公约数" class="headerlink" title="区间最大公约数"></a>区间最大公约数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为$N$的数列$A$，以及$M$条指令，每条指令可能是以下两种之一：</p><p>$C$ $l$ $r$ $d$，表示把 $A[l],A[l+1],…,A[r]$ 都加上$d$。<br>$Q$ $l$ $r$，表示询问$A[l],A[l+1],…,A[r]$的最大公约数($GCD$)。<br>对于每个询问，输出一个整数表示答案。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数$N,M$。</p><p>第二行$N$个整数$A[i]$。</p><p>接下来$M$行表示$M$条指令，每条指令的格式如题目描述所示。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N\leq 500000,M≤\leq 00000$,<br>$1\leq A[i]\leq 10^18$,<br>$|d|\leq 10^18$,<br>保证数据在计算过程中不会超过$long$ $long$范围。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 5 7 9</span><br><span class="line">Q 1 5</span><br><span class="line">C 1 5 1</span><br><span class="line">Q 1 5</span><br><span class="line">C 3 3 6</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>转换成差分数组</strong>，维护前缀和和差分数组的最大公约数(<strong>gcd(a,b,c) = gcd(a,b-a,c-b)</strong>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, d;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        LL b = w[r] - w[r - <span class="number">1</span>];</span><br><span class="line">        tr[u] = &#123;l, r, b, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        LL b = tr[u].sum + v;</span><br><span class="line">        tr[u] = &#123;x, x, b, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r),right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    Node res;</span><br><span class="line">    <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        string op;<span class="type">int</span> l,r;</span><br><span class="line">        LL d;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,d);</span><br><span class="line">            <span class="keyword">if</span>(r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(<span class="number">1</span>,r + <span class="number">1</span>,-d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l);</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">auto</span> right = <span class="built_in">query</span>(<span class="number">1</span>,l + <span class="number">1</span>,r);</span><br><span class="line">                cout &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum,right.d)) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">abs</span>(left.sum) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2024/04/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2024/04/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>并查集维护的是具有等价关系的等价类</strong></p><p>并查集支持两种操作：</p><ul><li>查询</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N];   <span class="comment">//p表示祖先节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? p[x]: p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合并</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h2 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h2><p>朴素并查集仅维护等价关系。</p><h3 id="格子游戏"><a href="#格子游戏" class="headerlink" title="格子游戏"></a>格子游戏</h3><p>$Alice$和$Bob$玩了一个古老的游戏：首先画一个 $n \times n$ 的点阵（下图 $n=3$ ）。</p><p>接着，他们两个轮流在相邻的点之间画上红边和蓝边，直到围成一个封闭的圈（面积不必为 $1$<br>）为止，“封圈”的那个人就是赢家。因为棋盘实在是太大了，他们的游戏实在是太长了！</p><p>他们甚至在游戏中都不知道谁赢得了游戏。</p><p>于是请你写一个程序，帮助他们计算他们是否结束了游戏？</p><p>输入格式<br>输入数据第一行为两个整数 $n$ 和 $m$。$n$表示点阵的大小，$m$ 表示一共画了 $m$ 条线。</p><p>以后 $m$ 行，每行首先有两个数字 $(x,y)$，代表了画线的起点坐标，接着用空格隔开一个字符，假如字符是 $D$，则是向下连一条边，如果是 $R$ 就是向右连一条边。</p><p>输入数据不会有重复的边且保证正确。</p><p>输出格式<br>输出一行：在第几步的时候结束。</p><p>假如 $m$ 步之后也没有结束，则输出一行“$draw$”。</p><p>数据范围<br>$1\leq n\leq 200$，<br>$1\leq m\leq 24000$</p><p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 1 D</span><br><span class="line">1 1 R</span><br><span class="line">1 2 D</span><br><span class="line">2 1 R</span><br><span class="line">2 2 D</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N * N; ++ i) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(<span class="built_in">get</span>(a,b));</span><br><span class="line">        <span class="type">int</span> pb;</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;D&#x27;</span>) pb = <span class="built_in">find</span>(<span class="built_in">get</span>(a + <span class="number">1</span>,b));</span><br><span class="line">        <span class="keyword">else</span> pb = <span class="built_in">find</span>(<span class="built_in">get</span>(a,b + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(pa == pb) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) cout &lt;&lt; <span class="string">&quot;draw&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>带权并查集主要用以维护<strong>集合内部具有一定关系</strong>的集合。</p><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a>奇偶游戏</h3><p>小 A 和小 B 在玩一个游戏。</p><p>首先，小 A 写了一个由 0 和 1 组成的序列 S，长度为 N。</p><p>然后，小 B 向小 A 提出了 M 个问题。</p><p>在每个问题中，小 B 指定两个数 l 和 r，小 A 回答 $S[l∼r]$ 中有奇数个 $1$ 还是偶数个 $1$。</p><p>机智的小 B 发现小 A 有可能在撒谎。</p><p>例如，小 A 曾经回答过 $S[1∼3]$ 中有奇数个 1，$S[4∼6]$ 中有偶数个 1，现在又回答 $S[1∼6]$ 中有偶数个 1，显然这是自相矛盾的。</p><p>请你帮助小 B 检查这 M 个答案，并指出在至少多少个回答之后可以确定小 A 一定在撒谎。</p><p>即求出一个最小的 k，使得 01 序列 S 满足第 1∼k 个回答，但不满足第 1∼k+1 个回答。</p><p>输入格式<br>第一行包含一个整数 N，表示 01 序列长度。</p><p>第二行包含一个整数 M，表示问题数量。</p><p>接下来 M 行，每行包含一组问答：两个整数 l 和 r，以及回答 even 或 odd，用以描述 $S[l∼r]$ 中有偶数个 $1$ 还是奇数个 $1$。</p><p>输出格式<br>输出一个整数 $k$，表示 $01$ 序列满足第 $1$∼$k$ 个回答，但不满足第 $1$∼$k+1$ 个回答，如果 $01$ 序列满足所有回答，则输出问题总数量。</p><p>数据范围<br>$N\leq 10^9,M\leq 5000$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, Base = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>) S[x] = ++ n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;even&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a + Base) == <span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展域并查集"><a href="#拓展域并查集" class="headerlink" title="拓展域并查集"></a>拓展域并查集</h2><p>拓展域并查集可以看作多个并查集的合并，用以维护集合之间存在一些关系，如食物链关系、冲突关系等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奇偶游戏</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, Base = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>) S[x] = ++ n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;even&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a + Base) == <span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>食材运输</title>
      <link href="/2024/04/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E9%A3%9F%E6%9D%90%E8%BF%90%E8%BE%93/"/>
      <url>/2024/04/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E9%A3%9F%E6%9D%90%E8%BF%90%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="食材运输"><a href="#食材运输" class="headerlink" title="食材运输"></a>食材运输</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在$T$市有很多个酒店，这些酒店对于不同种类的食材有不同的需求情况，莱莱公司负责每天给这些酒店运输食材。</p><p>由于酒店众多，如何规划运输路线成为了一个非常重要的问题。你作为莱莱公司的顾问，请帮他们解决这个棘手的问题。</p><p>$T$市有$N$个酒店，这些酒店由$N−1$条双向道路连接，所有酒店和道路构成一颗树。</p><p>不同的道路可能有不同的长度，运输车通过该道路所需要的时间受道路的长度影响。</p><p>在$T$市，一共有$K$种主流食材。</p><p>莱莱公司有$K$辆车，每辆车负责一种食材的配送，不存在多辆车配送相同的食材。</p><p>由于不同酒店的特点不同，因此不同酒店对食材的需求情况也不同，比如可能 1 号酒店只需要第$1,5$种食材，$2$号酒店需要全部的$K$种食材。</p><p>莱莱公司每天给这些公司运输食材。</p><p>对于运输第$i$种食材的车辆，这辆车可以从任意酒店出发，然后将食材运输到所有需要第$i$种食材的酒店。</p><p>假设运输过程中食材的装卸不花时间，运输车足够大使得其能够在出发时就装满全部所需食材，并且食材的重量不影响运输车的速度。</p><p>为了提高配送效率，这$K$辆车可以从不同的酒店出发。</p><p>但是由于$T$市对于食品安全特别重视，因此每辆车在配送之前需要进行食品安全检查。</p><p>鉴于进行食品安全检查的人手不足，最多可以设置$M$个检查点。</p><p>现在莱莱公司需要你制定一个运输方案：选定不超过$M$个酒店设立食品安全检查点，确定每辆运输车从哪个检查点出发，规划每辆运输车的路线。</p><p>假设所有的食材运输车在进行了食品安全检查之后同时出发，请制定一个运输方案，使得所有酒店的等待时间的最大值最小。</p><p>酒店的等待时间从运输车辆出发时开始计算，到该酒店所有需要的食材都运输完毕截至。</p><p>如果一个酒店不需要任何食材，那么它的等待时间为$0$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含$3$个正整数$N,M,K$，含义见题目描述。</p><p>接下来$N$行，每行包含$K$个整数。每行输入描述对应酒店对每种食材的需求情况，$1$表示需要对应的食材，$0$表示不需要。</p><p>接下来$N−1$行，每行包含$3$个整数$u,v,w$，表示存在一条通行时间为$w$的双向道路连接$u$号酒店和$v$号酒店。</p><p>保证输入数据是一颗树，酒店从$1$编号到$N$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示在你的方案中，所有酒店的等待时间的最大值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于所有数据，满足<br>$1\leq N\leq 10^2$,<br>$1\leq M\leq K\leq 10$,<br>$1\leq u,v\leq N$,<br>$1\leq w\leq 10^6$。</p><p>具体数据规模如下：</p><p><img src="/img/food1.png" alt=""></p><h2 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 1 2</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 2 7</span><br><span class="line">2 3 2</span><br><span class="line">2 4 4</span><br><span class="line">4 5 5</span><br><span class="line">4 6 3</span><br></pre></td></tr></table></figure><h2 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h2><p><img src="/img/food2.png" alt=""></p><p>样例$1$的输入数据如上图。</p><p>由于限制了最多只能设置$1$个检查点，因此可以设置两辆运输车的路径如下：</p><p><img src="food3.png" alt=""></p><h2 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 2 2</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 2 7</span><br><span class="line">2 3 2</span><br><span class="line">2 4 4</span><br><span class="line">4 5 5</span><br><span class="line">4 6 3</span><br></pre></td></tr></table></figure><h2 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例2解释"><a href="#样例2解释" class="headerlink" title="样例2解释"></a>样例2解释</h2><p>样例$2$的输入数据和样例$1$几乎完全相同，唯一的区别在于样例$2$中允许最多设置$2$个检查点。</p><p>我们可以设置两辆运输车的路径如下：</p><p><img src="/img/food4.png" alt=""></p><p>在$1$号酒店和$6$号酒店设置检查点，最晚拿到所有食材的酒店为$5$号酒店，等待时间为$15$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><strong>给定$n$个顶点的树，从中选取不超过$m$个点，在限定时间内实现区间覆盖</strong></p><ol><li><p>题目要求求解最长时间的最小值，这个值具有二段性：如果时间过小，则无论如何选取$m$个点，都不能实现$k$种食材完全运输完毕；如果时间过大，就有冗余。综上，对时间进行二分。</p></li><li><p>暂且不考虑至多选取$m$个点的限制，那么问题可以视为一个区间重复覆盖问题：对于任意一个点$i$，计算其运输$j$种物品的最长时间$d[i][j]$，$state[i]$是一个二进制数，表示在时限从i点出发所能运送完的食材种类状态，能运送完，则相应数位为$1$，否则为$0$；</p></li><li><p>根据$2$知，需要$DFS$预处理$d[i][j]$;</p></li><li><p>二分的$check$函数：状压$DP$，$f[j]$表示达到状态$j$所需选择的最少节点数量；那么如果<code>f[(1 &lt;&lt; k) - 1] &lt;= m</code>，$check$就返回真值即可。</p></li></ol><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>,M = <span class="number">15</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> food[N][M];    <span class="comment">//存储每个酒店对应的食物，1为需要，0为不要</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][M];    <span class="comment">//表示第i个点运送食材j到所有需要的酒店的至少耗时</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span> &lt;&lt; M];  <span class="comment">//j视为二进制数，f[j]表示j的数位为1的食材在时限内运送完所需要的最小检查站数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> state[N];   <span class="comment">//state存储二进制数，state[i]的数位1表示能在时限内从i酒店出发并运送完毕的食材种类</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,ne,w;</span><br><span class="line">&#125;e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[idx].to = y,e[idx].w = w,e[idx].ne = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs计算d[u][k]</span></span><br><span class="line"><span class="function">PII <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    PII res = &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;;   <span class="comment">//first表示所有需要运送的酒店的边权的二倍，second表示其中最长的一条路</span></span><br><span class="line">    <span class="keyword">if</span>(food[u][k]) res.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = e[i].ne) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i].to,w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        PII t = <span class="built_in">dfs</span>(j,u,k);</span><br><span class="line">        <span class="keyword">if</span>(t.y != <span class="number">-1</span>) &#123; <span class="comment">//表示子树中存在需要运送的酒店</span></span><br><span class="line">            res.x += t.x + w * <span class="number">2</span>;</span><br><span class="line">            res.y = <span class="built_in">max</span>(res.y,w + t.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) state[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &lt;= mid)</span><br><span class="line">                state[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; ++ i) f[i] = inf;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            f[i | state[j]] = <span class="built_in">min</span>(f[i | state[j]],f[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>] &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            cin &gt;&gt; food[i][j];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>;++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(a,b,w);<span class="built_in">add</span>(b,a,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">            PII t = <span class="built_in">dfs</span>(i,<span class="number">-1</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(~t.y) d[i][j] = t.x - t.y;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = inf;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 重复覆盖 </category>
          
          <category> 状压DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 重复覆盖 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palmprint Recognition</title>
      <link href="/2024/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Palmprint%20Recognition/"/>
      <url>/2024/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Palmprint%20Recognition/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> Palmprint Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列数量</title>
      <link href="/2024/04/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/%E5%BA%8F%E5%88%97%E6%95%B0%E9%87%8F/"/>
      <url>/2024/04/15/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/%E5%BA%8F%E5%88%97%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="不定方程正整数解的个数"><a href="#不定方程正整数解的个数" class="headerlink" title="不定方程正整数解的个数"></a>不定方程正整数解的个数</h1><script type="math/tex; mode=display">a_1 + a_2 + ... + a_n = k + 1, n\leq k, 1\leq a_i\leq n, i = 1,2,3...</script><p>假设有$k + 1$个球，则有$k$个空位，在这$k$个空位中选择$n$个插入隔板，方案数就是不定方程正整数解的个数。</p><blockquote><p>建立映射关系：$a_i$等于第$i$个区间的小球数量，二者一一对应</p></blockquote><h1 id="序列数量"><a href="#序列数量" class="headerlink" title="序列数量"></a><a href="https://www.acwing.com/problem/content/5571/">序列数量</a></h1><p>给定整数 $n,m$。</p><p>请你计算，一共有多少个长度为 $m$ 的非负整数序列 $a_1, a_2, …, a_m$ 满足 $1\leq a_1 + a_2 + … + a_m\leq n$。</p><p>由于结果可能很大，你只需要输出对 $10^6 + 3$ 取模后的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共一行，包含两个整数 $n,m$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示满足条件的非负整数序列数量对 $10^6 + 3$ 取模后的结果。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>前 $3$ 个测试点满足 $1\leq n,m\leq 5$。<br>所有测试点满足 $1\leq n\leq 5 \times 10^5, 1\leq m\leq 2 \times 10^5$。</p><h2 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 1</span><br></pre></td></tr></table></figure><h2 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h2 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h2 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个不等式，添加 $a_{m+1}$ 使之变成等式 :</p><script type="math/tex; mode=display">a_1 + a_2 + ... + a_m + a_{m+1} = n, 0\leq a_i\leq n - 1</script><p>这样只需减去一个不合法状态，即 $a_{m+1} = n$ 即可；</p><p>进一步，为了得到之前所述不定方程的形式，建立一一对应：</p><p><script type="math/tex">a_i + 1 = b_i</script> ,</p><p>方程转化为:</p><p><script type="math/tex">b_1 + ... + b_{m+1} = n + m + 1</script>;</p><p>则问题答案为$C_{n + m}^{m} - 1$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M  = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % M;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (LL)res * a % M;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL) a * a % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; ++ i, -- j) &#123;</span><br><span class="line">        res = (LL) res * j % M;</span><br><span class="line">        res = (LL) res * <span class="built_in">qmi</span>(i, M - <span class="number">2</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">C</span>(n + m,m) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 组合数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合计数 </tag>
            
            <tag> 隔板法 </tag>
            
            <tag> 不定方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火柴排队</title>
      <link href="/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/"/>
      <url>/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="离散化-树状数组"><a href="#离散化-树状数组" class="headerlink" title="离散化 树状数组"></a>离散化 树状数组</h1><h2 id="火柴排队"><a href="#火柴排队" class="headerlink" title="火柴排队"></a>火柴排队</h2><p>涵涵有两盒火柴，每盒装有 $n$ 根火柴，每根火柴都有一个高度。</p><p>现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为：</p><p>$∑i=(a_i−b_i)^2$<br>其中 $ai$ 表示第一列火柴中第 $i$ 个火柴的高度，$b_i$ 表示第二列火柴中第 $i_n$ 个火柴的高度。 </p><p>每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。</p><p>请问得到这个最小的距离，最少需要交换多少次？</p><p>如果这个数字太大，请输出这个最小交换次数对 $99999997$ 取模的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共三行，第一行包含一个整数 $n$，表示每盒中火柴的数目。 </p><p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。</p><p>第三行有 $n$ 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共一行，包含一个整数，表示最少交换次数对 $99999997$ 取模的结果。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq n\leq 10^5,0\leq 火柴高度\leq 2^31 − 1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>,MOD = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N],p[N],tr[N];    <span class="comment">//将a视为有序，c存储映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disc</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>,p + n + <span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[p[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i ; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">disc</span>(a),<span class="built_in">disc</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[a[i]] = i;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        b[i] = c[b[i]];</span><br><span class="line">        <span class="built_in">add</span>(b[i],<span class="number">1</span>);</span><br><span class="line">        res  = (res + <span class="built_in">query</span>(n) - <span class="built_in">query</span>(b[i])) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 离散化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA</title>
      <link href="/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LCA/LCA/"/>
      <url>/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LCA/LCA/</url>
      
        <content type="html"><![CDATA[<h1 id="倍增法求LCA"><a href="#倍增法求LCA" class="headerlink" title="倍增法求LCA"></a>倍增法求LCA</h1><ul><li>预处理 $depth[i]$，表示第 $i$ 个节点的深度，根节点为 $1$ ;</li><li>预处理 $fa[i][j]$，表示节点 $i$ 向上走 $2^j$ 步到达的节点；</li><li>不失一般性，假设 $depth[a] &gt; depth[b]$：<ul><li>首先让 $a$ 走到和 $b$ 同一层；</li><li>$a$ 和 $b$ 走到最近公告祖先的下一层；</li><li>$fa[a][0]$ 即是最近公共祖先</li></ul></li></ul><h2 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a><a href="https://www.acwing.com/problem/content/1174/">祖孙询问</a></h2><p>给定一棵包含 $n$ 个节点的有根无向树，节点编号互不相同，但不一定是 $1 ∼ n$。</p><p>有 $m$ 个询问，每个询问给出了一对节点的编号 $x$ 和 $y$，询问 $x$ 与 $y$ 的祖孙关系。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行包括一个整数 表示节点个数；</p><p>接下来 $n$ 行每行一对整数 $a$ 和 $b$，表示 $a$ 和 $b$ 之间有一条无向边。如果 $b$ 是 $−1$，那么 $a$ 就是树的根；</p><p>第 $n+2$ 行是一个整数 $m$ 表示询问个数；</p><p>接下来 $m$ 行，每行两个不同的正整数 $x$ 和 $y$，表示一个询问。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个询问，若 $x$ 是 $y$ 的祖先则输出 $1$，若 $y$ 是 $x$ 的祖先则输出 $2$，否则输出 0。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq n,m\leq 4 \times 10^4,1\leq 每个节点的编号\leq 4 \times 10^4$</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">234 -1</span><br><span class="line">12 234</span><br><span class="line">13 234</span><br><span class="line">14 234</span><br><span class="line">15 234</span><br><span class="line">16 234</span><br><span class="line">17 234</span><br><span class="line">18 234</span><br><span class="line">19 234</span><br><span class="line">233 19</span><br><span class="line">5</span><br><span class="line">234 233</span><br><span class="line">233 12</span><br><span class="line">233 13</span><br><span class="line">233 15</span><br><span class="line">233 19</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">10</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a, b;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//哨兵</span></span><br><span class="line">    depth[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = u;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>) &#123;   <span class="comment">//节点j尚未处理</span></span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; ++ k)</span><br><span class="line">                    fa[j][k] = fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>]; <span class="comment">//递推处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; -- k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b]) <span class="comment">//如果a走出树根，则fa[a][k] = 0,于是depth[fa[a][k]] = 0 ，永远不成立</span></span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;    <span class="comment">//走到同一层后，可能就是祖先</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; -- k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">            a = fa[a][k],b = fa[b][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">lca</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(a == t) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == t) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 图论 </category>
          
          <category> LCA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 最近公共祖先 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>质数</title>
      <link href="/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/"/>
      <url>/2024/04/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="试除法求质数"><a href="#试除法求质数" class="headerlink" title="试除法求质数"></a>试除法求质数</h1><p>**这里推荐写<code>i &lt;= x / i</code>，防止爆int```</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; (LL)i * i &lt;= x; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h1><h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2><p><strong>O(nlog(logn))</strong></p><p>筛掉所有质数的倍数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>将所有合数通过其最小质因子筛掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++ j) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 质数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 质数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><script type="math/tex; mode=display">C_a^b = C_{a-1}^{b} + C_{a-1}^{b-1}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % M;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; C[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><h2 id="乘法逆元-1"><a href="#乘法逆元-1" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>如果 $b$ 与 $p$ 互质，且对于任意整数 $a$，如果 $b|a$，则存在一个整数 $x$，$\frac{a}{b} \equiv {a \times x} \pmod p$, $x$ 称为 $b$ 的模 $p$ 逆元。</p><p>$b$ 存在乘法逆元的充要条件是 $b$ 与模数 $p$ 互质。当模数 $p$ 为质数时，$b^{p−2}$ 即为 $b$ 的乘法逆元。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>预处理出所有数据范围内的阶乘及其逆元，根据$C_a^b=\frac{a!}{b! \times (a - b)!}$。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>,M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N],infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)&#123;</span><br><span class="line">        fact[i] = (LL)fact[i<span class="number">-1</span>] * i % M;</span><br><span class="line">        infact[i] = (LL)infact[i<span class="number">-1</span>] * <span class="built_in">qmi</span>(i,M - <span class="number">2</span>,M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> res = (LL)fact[a] * infact[b] % M * infact[a-b] % M;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><script type="math/tex; mode=display">C_a^b=C_{a \bmod p}^{b \bmod p} \times C_{\frac{a}{p}}^{\frac{b}{p}}</script><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a,b;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(LL a,LL b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(LL a,LL b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; ++ i, -- j) &#123;</span><br><span class="line">        res = (LL)res * j % p;</span><br><span class="line">        res = (LL)res * <span class="built_in">qmi</span>(i,p - <span class="number">2</span>,p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a,LL b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    res = (LL)<span class="built_in">C</span>(a % p,b % p, p) * <span class="built_in">lucas</span>(a / p,b / p,p) % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lucas</span>(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><script type="math/tex; mode=display">C_a^b=\frac{a!}{b! \times (a - b)!}</script><p>根据算术基本定理，把三个数分解成若干质数乘积，然后约分，最后只剩高精度乘法运算。</p><p>如何求 $a$ 中包含多少个 $p$？</p><script type="math/tex; mode=display">cnt=\frac{a}{p} + \frac {a}{p^2} + ... + 0</script><blockquote><p>算出一个$p$的个数，然后是$p^2$的个数，$p^2$包含两个$p$,但是由于$p^2$中的一个$p$已经加上了，故只需加一次，以此类推。</p></blockquote><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t) &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++ j) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        res += x / p;</span><br><span class="line">        x /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">get_primes</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) </span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a,primes[i]) - <span class="built_in">get</span>(b,primes[i]) - <span class="built_in">get</span>(a - b,primes[i]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; cnt; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; ++ j)</span><br><span class="line">            res = <span class="built_in">mul</span>(res,primes[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 组合数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约数</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BA%A6%E6%95%B0/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h1><p>一个数可以分解成若干个质数的乘积。</p><p>$x = p_1^{a_1} + p_2^{a_2} + … + p_k^{a_k}$</p><h1 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据组合数学，设cnt为约数个数；</p><p><code>cnt = (a1 + 1) * (a2 + 1) * ... * (an + 1)</code>  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, ++ s;</span><br><span class="line">            res *= (s + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>设res为约数和，不难看出：</p><p>$res = (p_1^0 + … + p_1^{a_1}) \times … \times (p_k^0 + … + p_k^{a_k})$</p><h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数之和，答案对 $10^9+7$ 取模。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 $n$。</p><p>接下来 $n$ 行，每行包含一个整数 $a_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示所给正整数的乘积的约数之和，答案需对 $10^9+7$ 取模。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\leq n\leq 100,1\leq a_i\leq 2 \times 10^9$</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">252</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, ++ s;</span><br><span class="line">            primes[i] += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_val</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">1</span>; i &lt;= primes[x]; ++ i)</span><br><span class="line">        res = res * x % M + <span class="number">1</span> % M;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; val;</span><br><span class="line">        <span class="built_in">get</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : primes)</span><br><span class="line">       res = (LL)res * <span class="built_in">get_val</span>(p.first) % M;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 约数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约数个数 </tag>
            
            <tag> 约数之和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分解质因数</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从小到大枚大于1的约数，每次除尽；</p><p>注意如果最后x大于1，那么它也是质因数。</p><blockquote><p>算术基本定理</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_div</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = i,b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, ++ b;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 分解质因数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试除法 </tag>
            
            <tag> 质因数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用gcd(a,b)表示a、b的最大公约数，有：gcd(a,b) = gcd(b,a % b)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a : <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><p><code>gcd(a,b) * a * b</code></p><h1 id="公约数"><a href="#公约数" class="headerlink" title="公约数"></a>公约数</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>a,b的公约数一定可以整除gcd(a,b)，gcd(a,b)的约数一定是a,b的公约数</strong></p><blockquote><p>可以用算术基本定理简单证明</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,q;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; divs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_div</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= d; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(d % i == <span class="number">0</span>) &#123;</span><br><span class="line">            divs.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i / d != i) divs.<span class="built_in">push_back</span>(d / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(divs.<span class="built_in">begin</span>(),divs.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 约数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcd </tag>
            
            <tag> 最大公约数 </tag>
            
            <tag> 最小公倍数 </tag>
            
            <tag> 公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉降幂</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>计算 $a^k$ mod $p$ 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将 $k$ 看成二进制数，则可由若干个 $2^d$ 组合而成；</p><p>预处理出$a^1$ $a^2$ $a^4$ … $a^k$；</p><p>然后组合出$a^b$即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,p;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (LL)res * a % p;    <span class="comment">//如果此位为1，则需要组合</span></span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数论 </category>
          
          <category> 快速幂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星空之夜</title>
      <link href="/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E6%98%9F%E7%A9%BA%E4%B9%8B%E5%A4%9C/"/>
      <url>/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E6%98%9F%E7%A9%BA%E4%B9%8B%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="星空之夜"><a href="#星空之夜" class="headerlink" title="星空之夜"></a><a href="https://www.acwing.com/problem/content/1404/">星空之夜</a></h1><p>夜空深处，闪亮的星星以星群的形式出现在人们眼中，形态万千。</p><p>一个星群是指一组非空的在水平，垂直或对角线方向相邻的星星的集合。</p><p>一个星群不能是一个更大星群的一部分。</p><p>星群可能是相似的。</p><p>如果两个星群的形状、包含星星的数目相同，那么无论它们的朝向如何，都认为它们是相似的。</p><p>通常星群可能有 $8$ 种朝向，如下图所示：</p><p><img src="/img/starry-1.gif" alt=""></p><p>现在，我们用一个二维 $01$ 矩阵来表示夜空，如果一个位置上的数字是 $1$，那么说明这个位置上有一个星星，否则这个位置上的数字应该是 $0$。</p><p>给定一个夜空二维矩阵，请你将其中的所有星群用小写字母进行标记，标记时相似星群用同一字母，不相似星群用不同字母。</p><p>标注星群就是指将星群中所有的 $1$ 替换为小写字母。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 $W$，表示矩阵宽度。</p><p>第二行包含一个整数 $H$，表示矩阵高度。</p><p>接下来 $H$ 行，每行包含一个长度为 $W$ 的 $01$ 序列，用来描述整个夜空矩阵。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出标记完所有星群后的二维矩阵。</p><p>用小写字母标记星群的方法很多，我们将整个输出读取为一个字符串，能够使得这个字符串字典序最小的标记方式，就是我们想要的标记方式。</p><p>输出这个标记方式标出的最终二维矩阵。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$0\leq W,H\leq 100$,<br>$0\leq 星群数量 \leq 500$,<br>$0\leq 不相似星群数量 \leq26$,<br>$1\leq 星群中星星的数量 \leq160$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">23</span><br><span class="line">15</span><br><span class="line">10001000000000010000000</span><br><span class="line">01111100011111000101101</span><br><span class="line">01000000010001000111111</span><br><span class="line">00000000010101000101111</span><br><span class="line">00000111010001000000000</span><br><span class="line">00001001011111000000000</span><br><span class="line">10000001000000000000000</span><br><span class="line">00101000000111110010000</span><br><span class="line">00001000000100010011111</span><br><span class="line">00000001110101010100010</span><br><span class="line">00000100110100010000000</span><br><span class="line">00010001110111110000000</span><br><span class="line">00100001110000000100000</span><br><span class="line">00001000100001000100101</span><br><span class="line">00000001110001000111000</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a000a0000000000b0000000</span><br><span class="line">0aaaaa000ccccc000d0dd0d</span><br><span class="line">0a0000000c000c000dddddd</span><br><span class="line">000000000c0b0c000d0dddd</span><br><span class="line">00000eee0c000c000000000</span><br><span class="line">0000e00e0ccccc000000000</span><br><span class="line">b000000e000000000000000</span><br><span class="line">00b0f000000ccccc00a0000</span><br><span class="line">0000f000000c000c00aaaaa</span><br><span class="line">0000000ddd0c0b0c0a000a0</span><br><span class="line">00000b00dd0c000c0000000</span><br><span class="line">000g000ddd0ccccc0000000</span><br><span class="line">00g0000ddd0000000e00000</span><br><span class="line">0000b000d0000f000e00e0b</span><br><span class="line">0000000ddd000f000eee000</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>首先显然是找连通块，可以使用floodfill算法；</p></li><li><p>其次如何判断一个图形是否相似：相似包括对称、旋转，或者二者的组合；</p></li><li><p>一般的，计算连通块任意两点间的欧几里得距离之和用作哈希值；</p></li><li><p>注意，这是一种近似算法，可能会发生哈希冲突，可以多个哈希减小冲突可能性。</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">170</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PII s[M];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> hv[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    s[top++] = &#123;x,y&#125;;</span><br><span class="line">    g[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; m &amp;&amp; g[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> a = s[i].x - s[j].x,b = s[i].y - s[j].y;</span><br><span class="line">            key += <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> key = <span class="built_in">get_hash</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(hv[i] - key) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    hv[cnt ++] = key;</span><br><span class="line">    <span class="keyword">return</span> cnt - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">             top = <span class="number">0</span>;</span><br><span class="line">             <span class="built_in">dfs</span>(i,j);</span><br><span class="line">             <span class="type">char</span> id = <span class="built_in">get_id</span>();</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; top; ++ u)</span><br><span class="line">                g[s[u].x][s[u].y] = id;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 哈希 </category>
          
          <category> Flood Fill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> Flood Fill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三途川的摆渡人</title>
      <link href="/2024/04/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DFS/%E4%B8%89%E9%80%94%E5%B7%9D%E7%9A%84%E6%91%86%E6%B8%A1%E4%BA%BA/"/>
      <url>/2024/04/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DFS/%E4%B8%89%E9%80%94%E5%B7%9D%E7%9A%84%E6%91%86%E6%B8%A1%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="三途川的摆渡人"><a href="#三途川的摆渡人" class="headerlink" title="三途川的摆渡人"></a><a href="https://ac.nowcoder.com/acm/contest/77231/F">三途川的摆渡人</a></h1><p>小红这天来到了三途川，发现这里有一个摆渡人，名字叫小町。小町的职责是将一些灵魂运送到冥界。每个灵魂有一个特性，用整数$a_i$表示。但小町非常喜欢偷懒，她只想运送尽可能少的灵魂然后摸鱼。</p><p>已知当船上所有灵魂特性的 位与运算 正好等于$0$时，船才可以开动。小町想让小红帮忙抛弃掉尽可能多的灵魂（但不能全抛弃），这样自己才能最大限度的偷懒。请你帮小红计算出可以抛弃的灵魂的最多数量。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>本题有多组数据，每组第一行一个整数$n$，表示灵魂数量；第二行$n$个整数$a_i$表示灵魂特性（$0\leq a_i\leq n$）。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对于每组测试数据，输出一行一个整数表示答案。</p><p>如果无解，请输出-1。否则输出一个整数，代表小町可以抛弃的最多灵魂数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">复制</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">7 3 3 2 5</span><br><span class="line">5</span><br><span class="line">2 14 6 30 10</span><br><span class="line">输出</span><br><span class="line">3</span><br><span class="line">-1</span><br><span class="line">说明</span><br><span class="line">第一个测试数据，抛弃掉前三个灵魂，剩下的两个灵魂与运算恰好为0（2 &amp; 5 = 0），因此船可以开动。</span><br><span class="line">第二个测试数据，显然无论如何，船都是不能开动的。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>换句话说，要选择尽可能少的数，使得他们相与为0，即保证二进制的每一位至少包含1个0；</p><p>由于数据最大不超过127，令<code>a[i] = 127 - a[i]</code>，那么问题转化为选择尽可能少的数，使得1能覆盖整个二进制所有数位。</p><p>可以通过DFS暴力枚举所有数字选和不选，但是显然可以进行很多剪枝优化：</p><ul><li><p>IDA*： 限制搜索深度，并且设计估价函数计算至少还需要选几个数；</p></li><li><p>每次枚举每一列选择最少的情况</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>,M = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">col</span>(<span class="number">7</span>); <span class="comment">//记录每一位都有哪些选择</span></span><br><span class="line"><span class="type">int</span> log2[M];    <span class="comment">//预处理计算log2，用于确定列数/数位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//估价函数，每次将给数位所有选择选上，以保证最小待选次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span> - state; i ;i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        <span class="type">int</span> c = log2[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">        ++ res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> row : col[c]) i &amp;= ~row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth,<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!depth || <span class="built_in">h</span>(state) &gt; depth) <span class="keyword">return</span> state == (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span>;    <span class="comment">//depth为0或者估价大于depth，返回</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span> - state; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        <span class="type">int</span> c = log2[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">-1</span> || col[c].<span class="built_in">size</span>() &lt; col[t].<span class="built_in">size</span>()) t = c; <span class="comment">//选择选择最小的数位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> row : col[t]) </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth - <span class="number">1</span>,state | row))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++ i) log2[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++ i)</span><br><span class="line">            col[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i] = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span> - a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; ++ j)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt;&gt; j &amp; <span class="number">1</span>) col[j].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++ i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(col[i].<span class="built_in">begin</span>(),col[i].<span class="built_in">end</span>());</span><br><span class="line">            col[i].<span class="built_in">erase</span>(<span class="built_in">unique</span>(col[i].<span class="built_in">begin</span>(),col[i].<span class="built_in">end</span>()),col[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(depth &lt;= n &amp;&amp; !<span class="built_in">dfs</span>(depth,<span class="number">0</span>)) ++depth;</span><br><span class="line">        <span class="type">int</span> ans = n - depth;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; n) ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> DFS </category>
          
          <category> 重复覆盖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 重复覆盖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫雷</title>
      <link href="/2024/04/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DFS/%E6%89%AB%E9%9B%B7/"/>
      <url>/2024/04/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DFS/%E6%89%AB%E9%9B%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a><a href="https://www.acwing.com/problem/content/4410/">扫雷</a></h1><p>小明最近迷上了一款名为《扫雷》的游戏。</p><p>其中有一个关卡的任务如下：</p><p>在一个二维平面上放置着 $n$ 个炸雷，第 $i$ 个炸雷 $(x_i,y_i,r_i)$ 表示在坐标 $(x_i,y_i)$ 处存在一个炸雷，它的爆炸范围是以半径为 $r_i$ 的一个圆。</p><p>为了顺利通过这片土地，需要玩家进行排雷。</p><p>玩家可以发射 $m$ 个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 $j$ 个排雷火箭 $(x_j,y_j,r_j)$ 表示这个排雷火箭将会在 $(x_j,y_j)$ 处爆炸，它的爆炸范围是以半径为 $r_j$ 的一个圆，在其爆炸范围内的炸雷会被引爆。</p><p>同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。</p><p>现在小明想知道他这次共引爆了几颗炸雷？</p><p>你可以把炸雷和排雷火箭都视为平面上的一个点。</p><p>一个点处可以存在多个炸雷和排雷火箭。</p><p>当炸雷位于爆炸范围的边界上时也会被引爆。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含两个整数 $n$、$m$。</p><p>接下来的 $n$ 行，每行三个整数 $x_i,y_i,r_i$，表示一个炸雷的信息。</p><p>再接下来的 $m$ 行，每行三个整数 $x_j,y_j,r_j$，表示一个排雷火箭的信息。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数表示答案。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40\%$ 的评测用例：$0 \leq x,y\leq 10^9,0\leq n,m\leq 10^3,1\leq r\leq 10$，<br>对于 $100\%$ 的评测用例：$0\leq x,y\leq 10^9,0\leq n,m\leq 5 \times 10^4,1\leq r\leq 10$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">2 1</span><br><span class="line">2 2 4</span><br><span class="line">4 4 2</span><br><span class="line">0 0 5</span><br><span class="line">输出样例：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>示例图如下，排雷火箭 $1$ 覆盖了炸雷 $1$，所以炸雷 $1$ 被排除；炸雷 $1$ 又覆盖了炸雷 $2$，所以炸雷 $2$ 也被排除。</p><p><img src="/img/saolei.png" alt="扫雷"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题实际上是图的遍历问题，一个地雷如果能引爆另一个地雷，则连一条有向边。但是在本题中，最坏情况下可能有$100000 \times 50000$条边，显然会$TLE$、$MLE$；</p><p>我们需要做的是快速查找一个圆内有哪些地雷，因此我们可以使用哈希表来实现；</p><p>由于 $x,y\leq 1^9$ ，故哈希函数 $x \times 1^9 + y$ ，保证了所有点不会发生冲突；</p><p>由于圆的范围不好确定，故枚举矩形并加以判定即可；</p><p>此外，题目数据存在同一位置的多颗地雷，对于此，只需要存储最大半径即可。</p><p><strong>哈希表空间越大，查找一般越快速，故本题可以开十倍空间</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">999997</span>,null = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,r;</span><br><span class="line">&#125;C[N];</span><br><span class="line"></span><br><span class="line">LL h[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id[M];  <span class="comment">//  表示哈希表中该位置存的是哪一个点(同一位置半径最大的点)</span></span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,x,y,r;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">1000000001ll</span> + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL key = <span class="built_in">get</span>(x,y);</span><br><span class="line">    <span class="type">int</span> t = (key % M + M) % M;</span><br><span class="line">    <span class="keyword">while</span>(h[t] != null &amp;&amp; h[t] != key) t = (t + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x - r; i &lt;= x + r; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y - r; j &lt;= y + r; ++ j)</span><br><span class="line">            <span class="keyword">if</span>((x - i) * (x - i) + (y - j) * (y - j) &lt;= r * r) &#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">find</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(id[t] &amp;&amp; !st[t]) &#123;</span><br><span class="line">                    st[t] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(C[id[t]].x,C[id[t]].y,C[id[t]].r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        C[i] = &#123;x,y,r&#125;;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(h[t] == null) h[t] = <span class="built_in">get</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(!id[t] || C[id[t]].r &lt; r) id[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="built_in">dfs</span>(x,y,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(C[i].x,C[i].y);</span><br><span class="line">        <span class="keyword">if</span>(st[t]) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 哈希 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2024/04/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E5%93%88%E5%B8%8C/"/>
      <url>/2024/04/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p><strong>将输入映射到一个值域较小，可以方便比较的范围</strong></p><p>具体来说，我们需要存储一些很多的数据，如$-1^9$ ~ $1^9$，但是数据数量不多，如果能将数字映射到较小的范围下，我们就能快速进行查找。</p><p>哈希表插入、查找操作一般是$O(1)$的。</p><p>在哈希的构造中，一般包括插入、查询、删除等操作，对于删除操作，一般通过打标记实现。</p><p>如何映射？一般将数 $mod$ 一个大于数据数量的质数。</p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>一般开两到三倍的空间，减少哈希冲突。</p><p>删除操作打标记实现，如果清零，该位置后面的数就不会被查找到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x) k = (k + <span class="number">1</span>) % N;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>拉链法只需要一个稍大于数据量的数组空间（一般取质数）；</p><p>在链中插入值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;    <span class="comment">//处理负数</span></span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i]) </span><br><span class="line">        <span class="keyword">if</span>(e[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-数据结构"><a href="#STL-数据结构" class="headerlink" title="$STL$数据结构"></a>$STL$数据结构</h2><p>c++提供了一种哈希数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br></pre></td></tr></table></figure><p><strong>unordered_set一般速度慢于数组模拟哈希，尤其在字符串哈希中。</strong></p><h1 id="蓝桥杯-2016-省-AB-四平方和"><a href="#蓝桥杯-2016-省-AB-四平方和" class="headerlink" title="蓝桥杯 2016 省 AB 四平方和"></a><a href="https://www.luogu.com.cn/problem/P8635">蓝桥杯 2016 省 AB</a> 四平方和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>四平方和定理，又称为拉格朗日定理：</p><p>每个正整数都可以表示为至多 $4$ 个正整数的平方和。</p><p>如果把 $0$ 包括进去，就正好可以表示为 $4$ 个数的平方和。</p><p>比如：</p><p>$5=0^2+0^2+1^2+2^2$。</p><p>$7=1^2+1^2+1^2+2^2$。</p><p>对于一个给定的正整数，可能存在多种平方和的表示法。</p><p>要求你对 $4$ 个数排序使得 $0 \le a \le b \le c \le d$。</p><p>并对所有的可能表示法按 $a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>程序输入为一个正整数 $N(N&lt;5\times10^6)$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>要求输出 $4$ 个非负整数，按从小到大排序，中间用空格分开。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 2 2</span><br></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">773535</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 267 838</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>时限 3 秒, 256M。蓝桥杯 2016 年第七届省赛</p><p>蓝桥杯 2016 年省赛 A 组 H 题（B 组 H 题）。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">10</span>,M = <span class="number">7999997</span>,null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">PII h[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (res % M + M) % M;</span><br><span class="line">    <span class="keyword">while</span>(h[t].x != null &amp;&amp; h[t].x != res) t = (t + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++ i)</span><br><span class="line">        h[i].x = h[i].y = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c * c &lt;= n; ++ c)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = c; c * c + d * d &lt;= n; ++ d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res = c * c + d * d;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">find</span>(res);</span><br><span class="line">                h[t].x = res,h[t].y = <span class="built_in">min</span>(h[t].y,c);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a * a * <span class="number">4</span> &lt;= n; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b = a; a * a + b * b * <span class="number">3</span> &lt;= n; ++ b) &#123;</span><br><span class="line">            <span class="type">int</span> res = n - a * a - b * b;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(res);</span><br><span class="line">            <span class="keyword">if</span>(h[t].x != null) &#123;</span><br><span class="line">                <span class="type">int</span> c = h[t].y,d = <span class="built_in">sqrt</span>(h[t].x - h[t].y * h[t].y);</span><br><span class="line">                cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 数据结构 </category>
          
          <category> 哈希 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命之树</title>
      <link href="/2024/04/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%A0%91/"/>
      <url>/2024/04/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2015-省-B-生命之树"><a href="#蓝桥杯-2015-省-B-生命之树" class="headerlink" title="蓝桥杯 2015 省 B 生命之树"></a><a href="https://www.luogu.com.cn/problem/P8625">蓝桥杯 2015 省 B</a> 生命之树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 X 森林里，上帝创建了生命之树。</p><p>他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。</p><p>上帝要在这棵树内选出一个节点集合 $S$（允许为空集），使得对于 $S$ 中的任意两个点 $a,b$，都存在一个点列 ${a,v_1,v_2, \cdots ,v_k,b}$ 使得这个点列中的每个点都是 $S$ 里面的元素，且序列中相邻两个点间有一条边相连。</p><p>在这个前提下，上帝要使得 $S$ 中的点所对应的整数的和尽量大。</p><p>这个最大的和就是上帝给生命之树的评分。</p><p>经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$ 表示这棵树有 $n$ 个节点。</p><p>第二行 $n$ 个整数，依次表示每个节点的评分。</p><p>接下来 $n-1$ 行，每行 $2$ 个整数 $u,v$，表示存在一条 $u$ 到 $v$ 的边。由于这是一棵树，所以是不存在环的。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个数，表示上帝给这棵树的分数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 -2 -3 4 5</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $30\%$ 的数据，$n \le 10$。</p><p>对于 $100\%$ 的数据，$0&lt;n \le 10^5,$ 每个节点的评分的绝对值不超过 $10^6$。</p><p>时限 3 秒, 256M。</p><p>蓝桥杯 2015 省赛 B 组 J 题。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的问题转化为求连通块中所有点权的最大值；</p><p>$f[j]$表示以节点$j$为根的连通块中的最大点权和，那么$f[j]$应该等于所有点权和非零的子树点权之和；</p><p>注意，在本题中没有说明父子关系，即无向边，故$DFS$需要记录父节点。</p><p><strong>在洛谷上有一组数据，所有点的权值都为负，答案输出为$0$，但是题目说明$S$非空集合，这里应当是负数</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N * <span class="number">2</span>],ne[N * <span class="number">2</span>],idx;</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[root] = (LL)w[root];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[root]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j,root);</span><br><span class="line">        <span class="keyword">if</span>(f[j] &gt; <span class="number">0</span>) f[root] += f[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    LL res = f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病毒溯源</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="病毒溯源"><a href="#病毒溯源" class="headerlink" title="病毒溯源"></a><a href="https://www.acwing.com/problem/content/description/3468/">病毒溯源</a></h1><p>病毒容易发生变异。</p><p>某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><p>输入格式<br>输入在第一行中给出一个正整数$N$，即病毒种类的总数。于是我们将所有病毒从$0$到$N−1$进行号。</p><p>随后$N$行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k 变异株1 …… 变异株k</span><br></pre></td></tr></table></figure><p>其中$k$是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第$i$行对应编号为$i$的病毒$(0\lt i\leq N)$题目保证病毒源头有且仅有一个。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以$1$个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列${a_1,…,a_n}$比序列${b_1,…,b_n}$“小”，如果存在$1\leq k\leq n$满足$a_i = b_i$对所有$i\lt k$成立，且$a_k\lt b_k$。</p><p>数据范围<br>$1\leq N\leq 10^4$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">10</span><br><span class="line">3 6 4 8</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2 5 9</span><br><span class="line">0</span><br><span class="line">1 7</span><br><span class="line">1 2</span><br><span class="line">0</span><br><span class="line">2 3 1</span><br><span class="line">输出样例：</span><br><span class="line">4</span><br><span class="line">0 4 9 1</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>树形$DP$，$f[j]$表示以j为根节点的子树的所有链的最大值；</p><p>注意，题目要求字典序最小，即如果$f[j]$在更新时需要特殊处理相等的情况，具体请看代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t,a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    f[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[root]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(f[root] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">            f[root] = f[j] + <span class="number">1</span>;</span><br><span class="line">            path[root] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须是先更新小于，在考虑等于时的情况，才能保证一定是更新到等长链中的编号较小的节点的路径</span></span><br><span class="line">        <span class="keyword">if</span>(f[root] &lt;= f[j] + <span class="number">1</span>) path[root] = <span class="built_in">min</span>(path[root],j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        h[i] = <span class="number">-1</span>;</span><br><span class="line">        path[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">add</span>(i,a);</span><br><span class="line">            has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_fa[root]) ++ root;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[root]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = root; path[i] != <span class="number">0x3f3f3f3f</span>; i = path[i]) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有上司的舞会</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E6%A0%91%E5%BD%A2DP/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a><a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个整数 $n$。</p><p>第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。</p><p>第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表最大的快乐指数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>化整为零，先考虑子问题；</p><p>一棵树的最大值可由它的子树转移而来，且根节点的选择与否直接影响到子树的最大值，所以需要记录一个状态$0$表示不选根节点，$1$表示选择根节点；</p><p>$f[i][j]$表示以$i$为根的子树，$j$可以取$0$或者$1$，分别表示选择节点$i$的与否，其属性存储最大值。</p><p>我们需要从叶子节点开始，逐步转移到根节点，这里采用 DFS 进行搜素。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y,ne[idx] = h[x],h[x] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[root] == <span class="number">-1</span>) &#123;</span><br><span class="line">        f[root][<span class="number">0</span>] = <span class="number">0</span>,f[root][<span class="number">1</span>] = happy[root];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[root]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[root][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>],f[j][<span class="number">1</span>]);</span><br><span class="line">        f[root][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[root][<span class="number">1</span>] += happy[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        ++d[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单状压DP</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E7%AE%80%E5%8D%95%E7%8A%B6%E5%8E%8BDP/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E7%AE%80%E5%8D%95%E7%8A%B6%E5%8E%8BDP/</url>
      
        <content type="html"><![CDATA[<h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a></h1><p>给定一张$n$个点的带权无向图，点从$0∼n−1$标号，求起点$0$到终点$n−1$的最短 Hamilton 路径。</p><p><strong>输入格式</strong></p><p>第一行输入整数$n$。</p><p>接下来$n$行每行$n$个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为$a[i,j]$）。</p><p>对于任意的$x,y,z$，数据保证$a[x,x]=0$，$a[x,y]=a[y,x]$ 并且$a[x,y]+a[y,z]≥a[x,z]$。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最短 Hamilton 路径的长度。</p><p><strong>数据范围</strong></p><p>$1≤n≤20$</p><p>$0≤a[i,j]≤10^7$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">5</span><br><span class="line">0 2 4 5 1</span><br><span class="line">2 0 6 5 3</span><br><span class="line">4 6 0 8 3</span><br><span class="line">5 5 8 0 5</span><br><span class="line">1 3 3 5 0</span><br><span class="line">输出样例：</span><br><span class="line">18</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一道经典的旅行商 NP 问题。</p><p>一共 20 个点，共 20！种排列方式，暴力搜素肯定行不通；</p><p>观察这样两条路径：</p><ul><li><p>0 -&gt; 1 -&gt; 2 -&gt; 3 长度为18</p></li><li><p>0 -&gt; 2 -&gt; 1 -&gt; 3 长度为20</p></li></ul><p>显然，长度为 20 的路径肯定不是最终答案，我们不需要考虑这条路径；</p><p>因此问题转化为考虑经过了哪些点后最终到达某个点的最短 Hamilton 路径长度。</p><p>$f[i][j]$：$i$是一个二进制数，表示到达$j$点经过了哪些点，显然$i$的第$j$位保证为$1$；</p><p>$f[i][j]$可以由所有的第$j$位为$0$，第$k$位为$1$的状态$f[stk][k]$转移而来。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">1</span> &lt;&lt; N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">//起点长度为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)  <span class="comment">// 保证合法状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ;k &lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span>((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">// 合法状态</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="蓝桥杯-2023-省-B-飞机降落"><a href="#蓝桥杯-2023-省-B-飞机降落" class="headerlink" title="蓝桥杯 2023 省 B 飞机降落"></a><a href="https://www.luogu.com.cn/problem/P9241">蓝桥杯 2023 省 B</a> 飞机降落</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第$i$架飞机在$T[i]$时刻到达机场上空，到达时它的剩余油料还可以继续盘旋$D[i]$个单位时间，即它最早可以于$T[i]$时刻开始降落，最晩可以于$T[i] + D[i]$时刻开始降落。降落过程需要$L[i]$个单位时间。</p><p>一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。</p><p>请你判断$N架$飞机是否可以全部安全降落。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组数据。</p><p>第一行包含一个整数$T$，代表测试数据的组数。</p><p>对于每组数据，第一行包含一个整数$N$。</p><p>以下$N$行，每行包含三个整数$T[i],D[i],L[i]$ 。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出 <code>YES</code> 或者 <code>NO</code>，代表是否可以全部安全降落。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">0 100 10</span><br><span class="line">10 10 10</span><br><span class="line">0 2 20</span><br><span class="line">3</span><br><span class="line">0 10 20</span><br><span class="line">10 10 20</span><br><span class="line">20 10 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例说明】</strong></p><p>对于第一组数据，可以安排第$3$架飞机于$0$时刻开始降落，$20$时刻完成降落。安排第$2$架飞机于$20$时刻开始降落，$30$时刻完成降落。安排第$1$架飞机于$30$时刻开始降落，$40$时刻完成降落。</p><p>对于第二组数据，无论如何安排，都会有飞机不能及时降落。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>$f[i][j]$表示$i$中数位为$1$的飞机已经降落且最后一架降落的飞机是$j$的最小落地时间 （显然保证$i$的第$j$位为$1$）</strong></p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[N],d[N],l[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;d[i],&amp;l[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++ i) f[<span class="number">1</span> &lt;&lt; i][i] = t[i] + l[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line">                        <span class="keyword">if</span>(i - (<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; f[i - (<span class="number">1</span> &lt;&lt; j)][k] &lt;= t[j] + d[j])</span><br><span class="line">                            f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(t[j],f[i - (<span class="number">1</span> &lt;&lt; j)][k]) + l[j]);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            res = <span class="built_in">min</span>(f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j],res);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a><a href="https://www.acwing.com/problem/content/3497/">国际象棋</a></h1><p>众所周知，“八皇后” 问题是求解在国际象棋棋盘上摆放$8$个皇后，使得两两之间互不攻击的方案数。</p><p>已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹未尽。作为一个国际象棋迷，他想研究在$N \times M$的棋盘上，摆放$K$个马，使得两两之间互不攻击有多少种摆放方案。</p><p>由于方案数可能很大，只需计算答案除以$1000000007$(即$10^9+7$) 的余数。</p><p>如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字，位于 (x,y) 格的马（第 x 行第 y<br>列）可以攻击 $(x+1,y+2)$、$(x+1,y−2)$、$(x−1,y+2)$、$(x−1,y−2)$、$(x+2,y+1)$、$(x+2,y−1)$、$(x−2,y+1)$ 和 $(x−2,y−1)$ 共 8 个格子。</p><p><img src="/img/guojixiangqi.png" alt="国际象棋"></p><p><strong>输入格式</strong><br>输入一行包含三个正整数$N,M,K$，分别表示棋盘的行数、列数和马的个数。</p><p><strong>输出格式</strong><br>输出一个整数，表示摆放的方案数除以$1000000007$(即$10^9+7$) 的余数。</p><p><strong>数据范围</strong><br>对于 $5\%$ 的评测用例，$K=1$；对于另外 10% 的评测用例，$K=2$；<br>对于另外 $10\%$ 的评测用例，$N=1$；<br>对于另外 $20\%$ 的评测用例，$N,M≤6$，$K≤5$；<br>对于另外 $25\%$ 的评测用例，$N≤3，M≤20，K≤12$；<br>对于所有评测用例，$1≤N≤6，1≤M≤100，1≤K≤20$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入样例1：</span><br><span class="line">1 2 1</span><br><span class="line">输出样例1：</span><br><span class="line">2</span><br><span class="line">输入样例2：</span><br><span class="line">4 4 3</span><br><span class="line">输出样例2：</span><br><span class="line">276</span><br><span class="line">输入样例3：</span><br><span class="line">3 20 12</span><br><span class="line">输出样例3：</span><br><span class="line">914051446</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>$dp$问题的显著特征就是可以<strong>把大问题化成小问题，再化零为整</strong>；</p><p>考虑棋子的放置过程，显然如果一列一列的放置棋子，显然棋子的放置只会受到前两列的影响（同一列棋子显然不会发生冲突）；</p><p>于是我们考虑子问题：前$i$列已经放置完毕，并且第$i$列和第$i-1$列的状态分别是$a$、$b$，且已经放置了$j$枚棋子的方案数；</p><p>这时我们只需要顺序枚举每一列 $i$、$i - 1$ 列、 $i$ 列、$i - 2$列、棋子数目$j$即可；</p><p>最多循环次数$100 \times 64 \times 64 \times 64 \times 20$次;</p><p>这个数字大约是$5 \times 10^9$；</p><p>但是在枚举过程中状态之间需要保证不发生冲突，即$a$与$b$不能出现间隔$2$位为$1$的情况，<br>$c$与$a$同理，并且$c$与$b$不能出现间隔$1$位为$1$的情况；</p><p>此外，$j$的枚举从$b$中有的$1$的个数开始，到$k$结束；</p><p>在实际运行中，大约运算了七百多万次。</p><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>,M = <span class="number">110</span>,mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1</span> &lt;&lt; n; ++ a)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1</span> &lt;&lt; n; ++ b) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a &amp; (b &lt;&lt; <span class="number">2</span>) || b &amp; (a &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">1</span> &lt;&lt; n; ++ c) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(a &amp; (c &lt;&lt; <span class="number">2</span>) || c &amp; (a &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(c &amp; (b &lt;&lt; <span class="number">1</span>) || b &amp; (c &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">int</span> w = <span class="built_in">get</span>(b),v = <span class="built_in">get</span>(a);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j = v + w; j &lt;= k; ++ j)</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="built_in">get</span>(c) + v; t &lt;= k - w; ++ t)</span><br><span class="line">                                f[i][a][b][j] = (f[i][a][b][j] + f[i<span class="number">-1</span>][c][a][t])</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1</span> &lt;&lt; n; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1</span> &lt;&lt; n; ++ b)</span><br><span class="line">            res  = (res + f[m][a][b][k]) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 状压DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒙德里安的梦想</title>
      <link href="/2024/04/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/"/>
      <url>/2024/04/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/%E7%8A%B6%E5%8E%8BDP/%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙德里安的猜想"><a href="#蒙德里安的猜想" class="headerlink" title="蒙德里安的猜想"></a><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3842/">蒙德里安的猜想</a></h1><p>求把$N \times M$的棋盘分割成若干个$1 \times 2$的长方形，有多少种方案。</p><p>例如当$N=2$，$M=4$时，共有$5$种方案。当$N=2$，$M=3$时，共有$3$种方案。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组测试用例。</p><p>每组测试用例占一行，包含两个整数$N$和$M$。</p><p>当输入用例$N=0$，$M=0$时，表示输入终止，且该用例无需处理。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>每个测试用例输出一个结果，每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq N,M\leq 11$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br><span class="line">输出样例：</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure><p><img src="/img/dp1.jpg" alt="蒙德里安的梦想"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>数据范围为 1 ~ 11 ，考虑进行状压dp</strong></p><p>棋盘面积一定是偶数，否则不存在合法方案（本题保证一定合法）；</p><p>长方形的放置只存在横向和纵向两种方案，现只考虑横向放置长方形。当所有横向长方形防止完毕，纵向方案唯一确定。故只需考虑横向放置即可；</p><p>$f[i][j]$表示前$i-1$列已经放置好，且从第$i-1$列延伸出来的$1 \times 1$的小正方形的排列方式为$j$（$j$看成$n$位二进制数，第$d$行存在延伸过来的小正方形，则$j$的第$d$位为$1$，否则为$0$）的所有方案数；</p><p>状态转移：考虑由$f[i-1][k]$转移。合法的转移情况保证$j$和$k$的同一数位不能都是$1$，否则会发生重叠；并且当第$i$列、第$i-1$列放置完后，不允许存在由连续奇数行没有横向长方形；</p><p>对应上述两种情况，保证 <code>i &amp; k == 0</code> 且 <code>i | k 中没有连续奇数个0</code>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>,M = <span class="number">1</span> &lt;&lt; N;    <span class="comment">//N行，M中状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[M]; <span class="comment">//预处理所有合法状态</span></span><br><span class="line">LL f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m,n || m) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//统计连续0</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) </span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;  <span class="comment">//连续奇数个0，状态不合法</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;  <span class="comment">//注意末尾可能存在奇数个0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化f数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//f[0][0]什么都没放置，仅一种方案        </span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//枚举第i列的所有状态可以由i-1列的哪些状态转移过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])</span><br><span class="line">                        f[i][j] += (LL)f[i<span class="number">-1</span>][k];</span><br><span class="line">        <span class="comment">//f[m][0]表示前m-1列放好，且第m列没有任何延伸。注意，数组从0开始</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[m][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
          <category> 动态规划 </category>
          
          <category> 状压DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
